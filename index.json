[{"categories":["摄影","记录生活"],"content":"2021年10月 过完国庆没多久又又又又又又来武汉了… 结果刚走没多久成都那边就爆发了疫情，然后甲方爸爸最开始说要先隔离7天，结果临到要进园区的前一天告知不让进了(这时成都升为了高风险)。。。 emmm…在酒店白待了两周。。😣 周末依然是出去扫街 然后打卡了光谷的网红街 世界城，emmm… 唯一的印象就是各种小吃、饭店和扎堆的理发店… 然后就顺便理了个发，哈哈哈哈😂 在音乐喷泉胖戏耍的小朋友，羡慕他们的无忧无虑 意式风情街 还打卡了东湖植物园🤓 睡莲 ","date":"2022-01-10","objectID":"/2021%E5%B9%B410%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年10月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B410%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年4月 因为公司新的项目，人生第一次到武汉，周末闲暇之余肯定是要四处转转的😄 在酒店拍的窗外的高架桥，同一张照片调了2种颜色风格： 壕里壕气的甲方爸爸在南湖边的办公园区： emmm，不得不说武汉的天气是真的好，基本上都是蓝天白云，当然最美的还是傍晚湖边的晚霞 加班到深夜… 正午 这么好的阳光，不自拍一张可惜了，哈哈哈哈 逼格不够，黑白来凑😂 ","date":"2022-01-10","objectID":"/2021%E5%B9%B44%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年4月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B44%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年5月 没错，还没过完五一假期，就又马不停蹄的回到了武汉。。 这次换了个酒店，窗外的景色也就不一样了 中午吃饭的时候不经意抬头看到后马上掏出手机来了一张 吃完午饭回去路上再来一张，哈哈哈哈 加班加到差点晕倒，深夜挂了急诊输了一晚上的液，早上出院的时候先来了一碗热干面。emmmm… 果然是屋漏偏逢连夜雨，碗里吃出一个硕大的苍蝇遗体😭 ","date":"2022-01-10","objectID":"/2021%E5%B9%B45%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年5月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B45%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年6月 是的，我又又又来武汉了，还是出差。。🙁 南湖的晚霞算是一点点些许安慰吧（太喜欢这张了，所以忍不住多调了个黑白版的） 园区的花正艳 楼 云 线 中途回了一趟成都 跟家人聚了聚 然后，就又又又又飞武汉了…😶 ","date":"2022-01-10","objectID":"/2021%E5%B9%B46%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年6月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B46%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年7月 南湖的荷花开啦 来了这么多次，终于打卡了黄鹤楼😂 楼顶的视野是真的棒 网红机位😏 继续打卡打卡打卡 江汉路 坐了盘2块钱的轮渡，拍的这张最喜欢 长江大桥，忘了是几桥来着。。一桥？ 网红电视塔 夜景 湖北博物馆 当然还有勾践剑 当然还有曾侯乙编钟 忘了叫啥。。就觉得这个头很有神秘色彩 还是忘了叫啥。。 地铁站也不放过 南湖的晚霞真的是美炸 终于可以回家啦！！！ 虽然窗外下着雨，但心情很阳光 当然…高兴不了太久，回去没多久就又去了合肥。。。 （因为只呆了几天，就放在这里不另外开贴了） ","date":"2022-01-10","objectID":"/2021%E5%B9%B47%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年7月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B47%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年9月 因为在武汉这边新招了人，所以过来的频率终于没那么高了 隔了这么久，没变的是这边的晚霞，还是那么好看 ","date":"2022-01-10","objectID":"/2021%E5%B9%B49%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年9月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B49%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["PinPoint"],"content":"简介 pinpoint是开源在github上的一款全链路APM监控工具，提供了无侵入式的调用链监控、方法执行详情查看、应用状态信息监控等功能。基于GoogleDapper论文进行的实现，与另一款开源的全链路分析工具Zipkin类似，但相比Zipkin提供了无侵入式、代码维度的监控等更多的特性。 Pinpoint支持的功能比较丰富，可以支持如下几种功能： 服务拓扑图： 对整个系统中应用的调用关系进行了可视化的展示，单击某个服务节点，可以显示该节点的 详细信息，比如当前节点状态、请求数量等 实时活跃线程图： 监控应用内活跃线程的执行情况，对应用的线程执行性能可以有比较直观的了解 请求响应散点图： 以时间维度进行请求计数和响应时间的展示，拖过拖动图表可以选择对应的请求查看执行的详细情况 请求调用栈查看： 对分布式环境中每个请求提供了代码维度的可见性，可以在页面中查看请求针对到代码维度的执行详情，帮助查找请求的瓶颈和故障原因。 应用状态、机器状态检查： 通过这个功能可以查看相关应用程序的其他的一些详细信息，比如CPU使用情况，内存状态、垃圾收集状态，TPS和JVM信息等参数。 总体来说，使用pinpoint的一些优点： 可以掌握系统的整体响应速度情况，对系统运行情况能比较清晰 可以掌握各节点的响应速度情况，比如第三方服务接口，redis，mysql等 可以掌握单次请求的具体服务链路耗时情况，定位性能瓶颈 单次请求的具体服务链路请求信息，对于排查问题能提供帮助 监控各服务的JVM、线程池、数据库连接池使用情况，尤其是对分布式服务系统来说 github地址： ​ 项目地址：https://github.com/pinpoint-apm/pinpoint 官方docker部署地址：https://github.com/pinpoint-apm/pinpoint-docker ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"架构组成 Pinpoint 主要由 3 个组件外加 Hbase 数据库组成，三个组件分别为：Agent、Collector 和 Web UI ​ Agent组件： 用于收集应用端监控数据，无侵入式，只需要在启动命令中加入部分参数即可 Collector组件： 数据收集模块，接收Agent发送过来的监控数据，并存储到HBase WebUI： 监控展示模块，展示系统调用关系、调用详情、应用状态等，并支持报警等功能 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"安装Collector组件 使用docker-compose安装最新版本： # 克隆官方的docker部署git git clone https://github.com/naver/pinpoint-docker.git # 进入clone的目录 cd pinpoint-docker # 使用docker-compose拉取镜像和运行服务。注意docker-compose是需要单独安装的 docker-compose pull \u0026\u0026 docker-compose up -d 如果想安装历史或指定版本，可以直接指定git tags： # 克隆官方的docker部署git git clone https://github.com/naver/pinpoint-docker.git # 进入clone的目录 cd pinpoint-docker # 使用git命令切换到指定版本的tag git checkout {tag} # 使用docker-compose拉取镜像和运行服务。注意docker-compose是需要单独安装的 docker-compose pull \u0026\u0026 docker-compose up -d 如果部署的时候想使用一些自定义配置，例如指定的端口，可以通过修改 docker-compose.yml 和 .env 中对应的配置来实现，建议优先通过修改.env文件来做自定义配置 修改端口可以直接修改.env文件，默认端口是Pinpoint-Web：8079，QuickStart：8000和Flink：8081 部署完成之后，使用docker-compose ps命令即可查看所有容器： 访问 http://xx.xx.xx.xx:8079/ 即可浏览pinpoint页面 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:3:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"安装配置Agent组件 从github中pinpoint的Release发布页面中下载和Collector组件版本一致的Agent程序包 将Agent程序包上传到需要监控的服务器上，解压压缩包，修改pinpoint.config配置文件，一般只需修改文件中的profiler.collector.ip=127.0.0.1为前面所部署的Collector组件所在IP地址 配置文件分为local和Release版本，选择任一一个修改即可，但是需要在pinpoint-root.config文件中指定对应的配置版本 如果在多台服务器上部署了应用，那么就需要在多台机器上部署Agent组件 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:4:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"配置监听应用 pinpoint的监控完全是无侵入式的，配置起来也很简单，只需要在java应用的启动命令增加几个参数即可： # ${pinpointPath}是agent组件存放的路径，类似于JAVA_HOME -javaagent:${pinpointPath}/pinpoint-bootstrap-2.3.1.jar #'dpccb'可自定义命名，在pinpoint页面上显示的名称 -Dpinpoint.applicationName=dpccb #id可自定义命名，可以和Name一样 -Dpinpoint.agentId=dpccb 启动应用程序，打开应用页面访问一下，然后登陆pinpoint的Web页面即可看到相关的监控内容了 如果应用是通过容器方式运行的，也可以通过修改启动脚本和Dockerfile的方式来配置agent的监听 //修改启动命令 //把agent的存放目录挂载到应用的容器内 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:4:1","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"pinpoint功能介绍 详细使用教程可以参考这篇文章：pinpoint使用详解（图文版） ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"首页 选择一个需要查看的应用，即可在首页中以图形化的方式展示用户请求、服务间的调用关系等信息。另外还有响应时间分析图、调用散点图、响应时长分布、等待时长分布等。在右侧的调用统计图中用鼠标左键框选(如图上红框)即可查看选中部分的调用详情 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:1","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"调用详细信息 详情页，选择一个请求后下方会显示其详细信息，包含响应时间，请求过程中涉及的代码方法，sql语句等 选择混合视图后还可以同时查看调用树、服务器性能占用、server map等信息 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:2","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"应用检查工具 查看应用的其他细节，如CPU使用、内存/垃圾收集、TPS和JVM参数 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:3","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["Linux"],"content":" 新增atrandys大佬的一键安装脚本，支持centos7+/debian9+/ubuntu16+: wget --no-check-certificate https://raw.githubusercontent.com/cx9208/Linux-NetSpeed/master/tcp.sh chmod +x tcp.sh ./tcp.sh 新增Google原版BBR一键安装脚本： wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:0:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"BBR简介 BBR 是 Google 推出的一个「TCP 拥塞控制算法」，它是以 Linux 内核模块的形式加载，可以最大化 Linux Server 的网络吞吐量。 简单地说，开启 BBR 的 Linux Server 和不开启 BBR 的 Linux Server，在持续传输数据方面可以有非常大的不同。 BBR 尽管还没有在主流发行版中默认开启，但 Google 已经在 YouTube 网站上实践了很久，可以说是很成熟的一样技术了。 ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:1:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"检测 BBR 是否开启 在开始之前，先看看 BBR 是否已经启用了，执行这条指令可以返回当前 Linux 内核可以使用的 TCP 拥堵控制算法： sysctl net.ipv4.tcp_available_congestion_control 例如，在我的Server上返回了如下内容： net.ipv4.tcp_available_congestion_control = cubic reno 可以看到是没有BBR的，因为默认的 Ubuntu 16.04 用的是 Linux 4.4.0 内核，所以自然是看不到 BBR 的。 我们再次确认下系统当前启用的拥塞算法： sysctl net.ipv4.tcp_congestion_control 返回的内容是： net.ipv4.tcp_congestion_control = cubic 可以看到系统使用的是 cubic 这个默认的算法。接下去我们通过最标准的模式来为这台 Ubuntu 16.04 启用 BBR ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:2:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"为Ubuntu 16.04 安装/启用 BBR ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:3:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"安装 4.10+ 新内核 BBR 只能配合 Linux Kernel 4.10 以上内核才能使用。但是在 Ubuntu 16.04 上怎么使用 4.10 呢？难道要手动下载和安装吗？ 不能！这会有一个安全隐患，手动下载安装的新内核，无法保证后续能得到及时的安全更新。那么怎么办？这里推荐使用 HWE 版本的内核，它就在官方源里。 HWE，即：HareWare Enablement，是专门为在老的系统上支持新的硬件而推出的内核。你可以像安装其他软件包一样在 Ubuntu 16.04 里非常容易的安装它，只需要执行下面的命令： sudo apt-get install linux-generic-hwe-16.04 对！只需要这样就OK了！ 安装好以后重启系统，然后输入： uname -a 我的Server输出如下： Linux oneone 4.15.0-74-generic #83~16.04.1-Ubuntu SMP Wed Dec 18 04:56:23 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 可以看到系统内核已经升级到4.15.0了。 ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:3:1","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"启用 BBR 接下来就可以为新内核装载 BBR 模块了，分别执行： sudo modprobe tcp_bbr echo \"tcp_bbr\" | sudo tee -a /etc/modules-load.d/modules.conf 接下来我们再来查看系统支持的拥塞算法，可以看到BBR已经在里面了： root@oneone:~# sysctl net.ipv4.tcp_available_congestion_control net.ipv4.tcp_available_congestion_control = reno cubic bbr 接下来就正式启用BBR，把它设为系统的默认拥塞算法，分别执行： echo \"net.core.default_qdisc=fq\" | sudo tee -a /etc/sysctl.conf echo \"net.ipv4.tcp_congestion_control=bbr\" | sudo tee -a /etc/sysctl.conf sudo sysctl -p 最后，再来验证一下是否设置成功，可以看到BBR已经是默认算法： root@oneone:~# sysctl net.ipv4.tcp_congestion_control net.ipv4.tcp_congestion_control = bbr ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:3:2","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"为Centos7 安装/启用 BBR ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:4:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"安装 4.10+ 新内核 先查看系统版本： cat /etc/redhat-release #例如我的系统版本是7.6，输出如下: CentOS Linux release 7.6.1810 (Core) 添加elrepo源，然后升级内核，操作命令如下： #添加、更新源 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm #安装内核 yum --enablerepo=elrepo-kernel install kernel-ml -y 安装完成后，可以使用下方的命令查看系统已经安装了内核 awk -F\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /etc/grub2.cfg #例如我的系统查询结果如下，其中‘5.5.8’版本的内核是刚刚安装的： 0 : CentOS Linux (5.5.8-1.el7.elrepo.x86_64) 7 (Core) 1 : CentOS Linux (4.14.129-bbrplus) 7 (Core) 2 : CentOS Linux (0-rescue-05cb8c7b39fe0f70e3ce97e5beab809d) 7 (Core) 接着我们就把刚安装的CentOS Linux (5.5.8-1.el7.elrepo.x86_64) 7 (Core)内核设置为默认： grub2-set-default 0 设置完默认内核之后，使用uname -a查看时发现当前使用的内核还是之前的版本，这是因为切换内核后需要重启系统才能生效： #查看还是之前的版本： [root~]# uname -a Linux ip-172-31-21-55.ap-southeast-1.compute.internal 4.14.129-bbrplus #1 SMP Tue Jun 25 12:23:41 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux #重启系统即可生效 [root@~]# reboot ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:4:1","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"启用 BBR 编辑sysctl.conf文件，并添加如下内容： # 使用vim编辑文件 vim /etc/sysctl.conf #在文件中添加如下内容并保存： net.core.default_qdisc = fq net.ipv4.tcp_congestion_control = bbr 加载系统参数，并确认配置是否生效，如果生效会打印上方刚刚新增的内容： sysctl -p 最后，再次验证一下是否设置成功： [root@~]# sysctl net.ipv4.tcp_congestion_control #输出如下，则表示默认加速算法已经是bbr net.ipv4.tcp_congestion_control = bbr ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:4:2","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"用法: grep [选项]… PATTERN [FILE]… 在每个 FILE 或是标准输入中查找 PATTERN。 默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。 例如: grep -i 'hello world' menu.h main.c 正则表达式选择与解释: -E, --extended-regexp PATTERN 是一个可扩展的正则表达式(缩写为 ERE) -F, --fixed-strings PATTERN 是一组由断行符分隔的字符串。 -G, --basic-regexp PATTERN 是一个基本正则表达式(缩写为 BRE) -P, --perl-regexp PATTERN 是一个 Perl 正则表达式 -e, --regexp=PATTERN 用 PATTERN 来进行匹配操作 -f, --file=FILE 从 FILE 中取得 PATTERN -i, --ignore-case 忽略大小写 -w, --word-regexp 强制 PATTERN 仅完全匹配字词 -x, --line-regexp 强制 PATTERN 仅完全匹配一行 -z, --null-data 一个 0 字节的数据行，但不是空行 杂项: -s, --no-messages 不显示错误信息 -v, --invert-match 选中不匹配的行 -V, --version 显示版本信息并退出 --help 显示此帮助并退出 输出控制: -m, --max-count=NUM NUM 次匹配后停止 -b, --byte-offset 输出的同时打印字节偏移 -n, --line-number 输出的同时打印行号 --line-buffered 每行输出清空 -H, --with-filename 为每一匹配项打印文件名 -h, --no-filename 输出时不显示文件名前缀 --label=LABEL 将LABEL 作为标准输入文件名前缀 -o, --only-matching 只显示匹配PATTERN 部分的行 -q, --quiet, --silent 不显示所有常规输出 --binary-files=TYPE 设定二进制文件的TYPE 类型； TYPE 可以是`binary', `text', 或`without-match' -a, --text 等同于 --binary-files=text -I 等同于 --binary-files=without-match -d, --directories=ACTION 读取目录的方式； ACTION 可以是`read', `recurse',或`skip' -D, --devices=ACTION 读取设备、先入先出队列、套接字的方式； ACTION 可以是`read'或`skip' -r, --recursive 等同于--directories=recurse -R, --dereference-recursive 同上，但遍历所有符号链接 --include=FILE_PATTERN 只查找匹配FILE_PATTERN 的文件 --exclude=FILE_PATTERN 跳过匹配FILE_PATTERN 的文件和目录 --exclude-from=FILE 跳过所有除FILE 以外的文件 --exclude-dir=PATTERN 跳过所有匹配PATTERN 的目录。 -L, --files-without-match 只打印不匹配FILEs 的文件名 -l, --files-with-matches 只打印匹配FILES 的文件名 -c, --count 只打印每个FILE 中的匹配行数目 -T, --initial-tab 行首tabs 分隔（如有必要） -Z, --null 在FILE 文件最后打印空字符 文件控制: -B, --before-context=NUM 打印文本及其前面NUM 行 -A, --after-context=NUM 打印文本及其后面NUM 行 -C, --context=NUM 打印NUM 行输出文本 -NUM 等同于 --context=NUM --color[=WHEN], --colour[=WHEN] 使用标记高亮匹配字串； WHEN 可以是`always', `never'或`auto' -U, --binary 不要清除行尾的CR 字符(MSDOS/Windows) -u, --unix-byte-offsets 忽略CR 字符，报告字节偏移 (MSDOS/Windows) egrep 即grep -E。fgrep 即grep -F。 直接调用egrep 或是fgrep 均已被废弃。 若FILE 为 -，将读取标准输入。不带FILE，读取当前目录，除非命令行中指定了-r 选项。 如果少于两个FILE 参数，就要默认使用-h 参数。 如果有任意行被匹配，那退出状态为 0，否则为 1； 如果有错误产生，且未指定 -q 参数，那退出状态为 2。 ","date":"2020-02-26","objectID":"/grep/:0:0","tags":["Linux"],"title":"grep","uri":"/grep/"},{"categories":["Linux","vim"],"content":"在使用vim时，当我们以普通用户去打开一个只有root用户才有权限操作的文件时，我们编辑完成之后，正要保存，却发现，这个文件我们没有权限修改。 经过查找，发现一个命令可以解决这个问题 命令： :w !sudo tee % w： 表示保存文件 ！： 表示执行外部命令 tee： linux命令，这个有点复杂，可以查看linux命令帮助 %： 在执行外部命令时，%会扩展成当前文件名；这个%区别于替换时的%，替换时%的意义是代表整个文件，而不是文件名 此命令是把当前文件（即%）作为stdin传给sudo tee命令来执行。说起来挺绕口，其实就是：用sudo强制保存。 这行命令解决了不能保存只读文件的问题，但毕竟命令还是有些长，为了避免每次输入一长串的命令，可以将它映射为一个简单的命令加到 .vimrc 中： \" Allow saving of files as sudo when I forgot to start vim using sudo. cmap w!! w !sudo tee \u003e /dev/null % 这样，简单的运行:w!!即可。命令后半部分\u003e /dev/null作用为显式的丢掉标准输出的内容。 ","date":"2020-02-25","objectID":"/vim%E6%9D%83%E9%99%90%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BC%BA%E5%88%B6%E4%BF%9D%E5%AD%98%E5%8F%AA%E8%AF%BB%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["vim"],"title":"Vim权限不足时强制保存只读类型文件的方法","uri":"/vim%E6%9D%83%E9%99%90%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BC%BA%E5%88%B6%E4%BF%9D%E5%AD%98%E5%8F%AA%E8%AF%BB%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["软件测试","Jmeter"],"content":"脚本规范： 目录结构按系统级别区分不同的jmx文件，每个系统一个jmx文件进行管理 线程组作为模块级别，命名格式为模块名称 接口作为用例级别，命名格式类似为 ： 【编号】 【正例/反例】用例名称 使用用户定义的变量将系统中使用到的全局变量抽取到全局自定义变量中，只支持抽取整个系统公用变量 使用用户定义的变量将模块中使用到的测试数据抽取到局部自定义变量中 每个接口都需要增加断言，保证脚本的结果的正确性 尽量将环境变量抽取到全局中，方便环境切换 提交测试脚本时尽量删除自己创建的垃圾数据 ","date":"2020-02-25","objectID":"/jmeter/:0:0","tags":["Jmeter"],"title":"Jmeter","uri":"/jmeter/"},{"categories":["Linux"],"content":"系统 uname -a** 查看内核/操作系统/CPU信息 head -n 1 /etc/issue 查看操作系统版本 *cat /proc/cpuinfo 查看CPU信息 hostname** 查看计算机名 lspci -tv 列出所有PCI设备 lsusb -tv 出所有USB设备 lsmod 列出加载的内核模块 env 查看环境变量 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"资源 free -m 查看内存使用量和交换区使用量 df -h 查看各分区使用情况 du -sh \u003c目录名\u003e 查看指定目录的大小 grep MemTotal /proc/meminfo 查看内存总量 grep MemFree /proc/meminfo 查看空闲内存量 uptime 查看系统运行时间、用户数、负载 cat /proc/loadavg 查看系统负载 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"磁盘和分区 mount | column -t 查看挂接的分区状态 fdisk -l 查看所有分区 swapon -s 查看所有交换分区 hdparm -i /dev/hda 查看磁盘参数(仅适用于IDE设备) dmesg | grep IDE 查看启动时IDE设备检测状况 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"网络 ifconfig 查看所有网络接口的属性 iptables -L 查看防火墙设置 route -n 查看路由表 netstat -lntp 查看所有监听端口 netstat -antp 查看所有已经建立的连接 netstat -s 查看网络统计信息 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"进程 ps -ef 查看所有进程 top 实时显示进程状态 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"用户 w 查看活动用户 id \u003c用户名\u003e 查看指定用户信息 last 查看用户登录日志 cut -d: -f1 /etc/passwd 查看系统所有用户 cut -d: -f1 /etc/group 查看系统所有组 crontab -l 查看当前用户的计划任务 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"服务 chkconfig –list 列出所有系统服务 chkconfig –list | grep on 列出所有启动的系统服务 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"程序 apt-get update 在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。 apt-get install packagename 安装一个新软件包（参见下文的aptitude） apt-get remove packagename 卸载一个已安装的软件包（保留配置文件） apt-get –purge remove packagename 卸载一个已安装的软件包（删除配置文件） dpkg –force-all –purge packagename 有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。 apt-get autoclean apt 会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件 apt-get clean 这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。 apt-get upgrade 更新所有已安装的软件包 apt-get dist-upgrade 将系统升级到新版本 apt-cache search string 在软件包列表中搜索字符串 dpkg -l package-name-pattern 列出所有与模式相匹配的软件包。如果您不知道软件包的全名，您可以使用“package-name-pattern”。 aptitude 详细查看已安装或可用的软件包。与apt-get类似，aptitude可以通过命令行方式调用，但仅限于某些命令——最常见的有安装和卸载命令。由于aptitude比apt-get了解更多信息，可以说它更适合用来进行安装和卸载。 apt-cache showpkg pkgs 显示软件包信息。 apt-cache dumpavail 打印可用软件包列表。 apt-cache show pkgs 显示软件包记录，类似于dpkg –print-avail。 apt-cache pkgnames 打印软件包列表中所有软件包的名称。 dpkg -S file 这个文件属于哪个已安装软件包。 dpkg -L package 列出软件包中的所有文件。 apt-file search filename 查找包含特定文件的软件包（不一定是已安装的），这些文件的文件名中含有指定的字符串。 apt-file 是一个独立的软件包。您必须 先使用apt-get install来安装它，然后运行apt-file update。如果apt-file search filename 输出的内容太多，您可以尝试使用apt-file search sfilename | grep -w filename s（只显示指定字符串作为完整的单词出现在其中的那些文件名）或者类似方法，例如：apt-file search filename | grep /bin/（只显示位于诸如/bin或/usr/bin这些文件夹中的文件，如果您要查找的是某个特定的执行文件的话，这样做是有帮助的）。 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"问题现象 ​ 按照网上配置java环境变量的方法在/etc/profile文件中添加如下内容，配置之后，如果重启系统后切换到root用户无法获取已配置的java环境变量，在普通用户下可以获取到 export JAVA_HOME=/usr/local/java/jdk1.8.0_65 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH ","date":"2020-02-24","objectID":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:1:0","tags":["ubuntu"],"title":"Ubuntu root用户下java -version无法获取java环境变量解决办法","uri":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["Linux"],"content":"解决办法 sudo ln -s /你的jdk路径/bin/jar /bin/jar sudo ln -s /你的jdk路径/bin/java /bin/java sudo ln -s /你的jdk路径/bin/javac /bin/javac sudo ln -s /你的jdk路径/bin/javah /bin/javah sudo ln -s /你的jdk路径/bin/javadoc /bin/javadoc ","date":"2020-02-24","objectID":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:2:0","tags":["ubuntu"],"title":"Ubuntu root用户下java -version无法获取java环境变量解决办法","uri":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["Linux","oh-my-zsh"],"content":"如果使用wt用户安装配置了oh-my-zsh，其他用户想要使用相同的主题和配置，可以参考https://askubuntu.com/questions/521469/oh-my-zsh-for-the-root-and-for-all-user 这里介绍一种更简单的方法（亲测有效）： 比如让root用户使用和wt用户相同的配置： sudo ln -s $HOME/.oh-my-zsh /root/.oh-my-zsh sudo ln -s $HOME/.zshrc /root/.zshrc 切换到root用户，命令zsh,即可看到zsh的主题和wt用户的一样了。如果提示 /root/.zshrc:119: command not found: pyenv /root/.zshrc:120: command not found: pyenv 再创建.pyenv的软连接即可。 sudo ln -s $HOME/.pyenv /root/.pyenv 这样做的缺点是root用户的所有配置都和wt用户的一致，不能个性化。修改一个，其他用户的也会变。 如果要个性化，可以用 sudo cp -r /home/wt/.oh-my-zsh /root sudo cp -r /home/wt/.zshrc /root ","date":"2020-02-24","objectID":"/%E8%AE%A9%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8oh-my-zsh/:0:0","tags":["oh-my-zsh"],"title":"让其他用户使用oh-my-zsh","uri":"/%E8%AE%A9%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8oh-my-zsh/"},{"categories":["Linux","Docker"],"content":" docker 服务重启，关闭，启动及版本查看 [root@localhost /] systemctl restart docker.service #重启服务 [root@localhost /] systemctl stop docker.service #关闭服务 [root@localhost /] systemctl start docker.service #启动服务 [root@iZm5e3hwzuo58e05kxjiifZ /] docker -v #docker版本查看 Docker version 18.06.1-ce, build e68fc7a docker 搜索/下载/查看镜像 [root@localhost /] docker search centos|head -3 #搜索镜像 NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 4754 [OK] [root@localhost /] docker pull centos #下载镜像 Using default tag: latest............. Digest: sha256:6f6d986d425aeabdc3a02cb61c02abb2e78e57357e92417d6d58332856024faf Status: Downloaded newer image for centos:latest [root@localhost /] docker images #查看镜像 REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5182e96772bf 7 weeks ago 200MB docker 创建一个容器（前台/后台并指定映射目录和端口） -i：允许我们对容器内的 (STDIN) 进行交互 -t：在新容器内指定一个伪终端或终端 -v：是挂在宿机目录， /docker_test是宿机目录，/yufei是当前docker容器的目录，宿机目录必须是绝对的。 --name：是给容器起一个名字，可省略，省略的话docker会随机产生一个名字 -P 指定映射的端口 --net #指定网络 --link 链接到另一个容器 -------------------------------------------------------------------------------------------------- docker run -it -v /test:/test --name centos /bin/bash #创建容器并进入（交互模式退出会后容器会自动关闭） docker run -d -v /test:/test centos tail -f /dev/null #创建容器并放入后台运行（退出容器不会关闭） docker run -dit -v /test:/test centos /bin/bash #创建容器并放入后台运行（进入后台和tty模式，退出容器不会关闭） docker run -d -v /test:/test -P 80:80 nginx:latest #后台启动并运名为nginx的容器，然后将容器的80端口映射到物理机的80端口. 查看docker创建的所有容器 [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker ps -a #查看所有创建的容器包括已经停止的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 70e151cd2766 centos “/bin/bash” 7 seconds ago Exited (0) 5 seconds ago zealous_mclean dfdf33852d47 centos “/bin/bash” 20 seconds ago Up 19 seconds frosty_saha [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker ps #查看所有运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dfdf33852d47 centos “/bin/bash” 22 seconds ago Up 21 seconds frosty_saha [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker ps -l #查看最新创建的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 70e151cd2766 centos “/bin/bash” 29 minutes ago Exited (0) 29 minutes ago zealous_mclean ``` docker 利用已存在的容器创建一个镜像（Dockerfile构建镜像略） -a #提交的镜像作者 -c #使用Dockerfile指令来创建镜像 -m #提交时附上说明文字 -p #在commit时，将容器暂停 ------------------------------------------------------------------------------------------- [root@iZm5e3hwzuo58e05kxjiifZ ~] docker commit -a \"王云龙\" -m \"创建的新镜像\" redis wyl5588redis-test sha256:9c2d2fc6e09cb35543fbb2467db90e741dc6b7daabab83924534bcfe6641bbe2 [root@iZm5e3hwzuo58e05kxjiifZ ~] docker images REPOSITORY TAG IMAGE ID CREATED SIZE wyl5588redis-test latest 9c2d2fc6e09c 3 seconds ago 83.4MB docker 修改镜像标签，并推送 [root@iZm5e3hwzuo58e05kxjiifZ Dockerfile] docker tag centos 192.168.8.88:5000/centos:v1.0 #给centos镜像打一个行的tag [root@iZm5e3hwzuo58e05kxjiifZ Dockerfile] docker images REPOSITORY TAG IMAGE ID CREATED SIZE 192.168.8.88:5000/centos v1.0 5182e96772bf 7 weeks ago 200MB centos latest 5182e96772bf 7 weeks ago 200MB [root@iZm5e3hwzuo58e05kxjiifZ Dockerfile]docker push 192.168.8.88:5000/centos:v1.0 #将本地docker中的镜像推送到镜像仓库中 docker镜像的导入，导出，删除 docker save 5588/mongo3.2 5588/redis 5588/nginx 5588/qiantai \u003eQiantai_images.tar #镜像导出 docker load \u003c/Docker_Images/Qiantai.images.tar #镜像导入 docker rmi centos #删除centos镜像 docker rmi -f centos #强制删除 docker images -q #获取进行的ID docker rmi -f $(docker images -q)#删除全部镜像 docker 容器与宿主机文件拷贝 [root@iZm5e3hwzuo58e05kxjiifZ ~] touch admin [root@iZm5e3hwzuo58e05kxjiifZ ~] docker cp ./admin nginx:/tmp/ [root@iZm5e3hwzuo58e05kxjiifZ ~] docker exec -it nginx /bin/bash root@aaefa2aebc8b:/ ls /tmp admin root@aaefa2aebc8b:/ touch /tmp/wyltest exit [root@iZm5e3hwzuo58e05kxjiifZ ~] docker cp -a nginx:/tmp/wyltest ./ Error: No such container:path: nginx:/tmp/* [root@iZm5e3hwzuo58e05kxjiifZ ~] docker cp -a nginx:/tmp/admin ./ 查看docker 容器详情如：ip等 [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker inspect frosty_saha #查看容器详情如ip等frosty_saha为容器别名 [ { “Id”: “dfdf33852d470d0cd8e70a4b9aad36a00585579952834471159100aacea885d9”, “Created”: “2018-09-28T0","date":"2020-02-24","objectID":"/docker-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:0:0","tags":["Linux","Docker"],"title":"Docker-常用基础命令","uri":"/docker-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux","vim"],"content":"自用的vimrc配置文件备份: \" encoding dectection set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 \" Set vundle settings here \" git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim set nocompatible \" be iMproved, required filetype off \" required \" set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \" alternatively, pass a path where Vundle should install plugins \"call vundle#begin('~/some/path/here') \" let Vundle manage Vundle, required \"Plugin 'VundleVim/Vundle.vim' \"https://github.com/VundleVim/Vundle.vim Bundle 'Valloric/YouCompleteMe' Plugin 'gmarik/Vundle.vim' \" Custom plugins Plugin 'scrooloose/nerdtree' \"https://github.com/scrooloose/nerdtree Plugin 'MattesGroeger/vim-bookmarks' \"https://github.com/MattesGroeger/vim-bookmarks Plugin 'maciakl/vim-neatstatus' \"https://github.com/maciakl/vim-neatstatus \" All of your Plugins must be added before the following line call vundle#end() \" required filetype plugin indent on \" required \" To ignore plugin indent changes, instead use: \"filetype plugin on \" \" Brief help \" :PluginList - lists configured plugins \" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate \" :PluginSearch foo - searches for foo; append `!` to refresh local cache \" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal \" \" see :h vundle for more details or wiki for FAQ \" Put your non-Plugin stuff after this line \" Vim5 and later versions support syntax highlighting. Uncommenting the \" following enables syntax highlighting by default. if has(\"syntax\") syntax on \" 语法高亮 endif \" Uncomment the following to have Vim jump to the last position when \" reopening a file if has(\"autocmd\") au BufReadPost * if line(\"'\\\"\") \u003e 1 \u0026\u0026 line(\"'\\\"\") \u003c= line(\"$\") | exe \"normal! g'\\\"\" | endif \"have Vim load indentation rules and plugins according to the detected \"filetype on \"filetype plugin indent on endif set number set autoindent set softtabstop=4 \" 设置软制表符的宽度 set shiftwidth=4 \" (自动) 缩进使用的4个空格 set tabstop=4 \" 设置制表符(tab键)的宽度 set expandtab \" 行首tab转换为4个空格 set cindent \" 使用 C/C++ 语言的自动缩进方式 set cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,\u003e1s,=1s,:1s \"设置C/C++语言的具体缩进方式 set showmatch \" 设置匹配模式，显示匹配的括号 set linebreak \" 整词换行 set whichwrap=b,s,\u003c,\u003e,[,] \" 光标从行首和行末时可以跳到另一行去 set ruler \" 标尺，用于显示光标位置的行号和列号，逗号分隔。每个窗口都有自己的标尺。如果窗口有状态行，标尺在那里显示。否则，它显示在屏幕的最后一行上 set showcmd \" 命令行显示输入的命令 set showmode \" 命令行显示vim当前模式 set incsearch \" 输入字符串就显示匹配点 set hlsearch set enc=utf-8 \" 文件编码 set cursorline set cursorcolumn highlight CursorLine cterm=NONE ctermbg=blue ctermfg=white guibg=NONE guifg=NONE \"highlight CursorColumn cterm=NONE ctermbg=green ctermfg=NONE guibg=NONE guifg=NONE highlight CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white \" NERDTree settings autocmd StdinReadPre * let s:std_in=1 autocmd VimEnter * if argc() == 0 \u0026\u0026 !exists(\"s:std_in\") | NERDTree | endif \" vim-bookmarks settings let g:bookmark_auto_close = 1 let g:bookmark_save_per_working_dir = 1 let g:bookmark_highlight_lines = 1 let g:bookmark_center = 1 let g:bookmark_location_list = 1 \" key mapping :inoremap { {}\u003cESC\u003ei :map \u003cf2\u003e :NERDTreeToggle\u003cCR\u003e ","date":"2020-02-24","objectID":"/vimrc-%E5%A4%87%E4%BB%BD/:0:0","tags":["vim","Linux"],"title":".vimrc-备份","uri":"/vimrc-%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"\r\r404\r\r\r\r\r\r","date":"0001-01-01","objectID":"/404/:0:0","tags":null,"title":"404","uri":"/404/"}]