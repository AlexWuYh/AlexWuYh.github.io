[{"categories":["摄影","记录生活"],"content":"2021年10月 过完国庆没多久又又又又又又来武汉了… 结果刚走没多久成都那边就爆发了疫情，然后甲方爸爸最开始说要先隔离7天，结果临到要进园区的前一天告知不让进了(这时成都升为了高风险)。。。 emmm…在酒店白待了两周。。😣 周末依然是出去扫街 然后打卡了光谷的网红街 世界城，emmm… 唯一的印象就是各种小吃、饭店和扎堆的理发店… 然后就顺便理了个发，哈哈哈哈😂 在音乐喷泉胖戏耍的小朋友，羡慕他们的无忧无虑 意式风情街 还打卡了东湖植物园🤓 睡莲 ","date":"2022-01-10","objectID":"/2021%E5%B9%B410%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年10月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B410%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年4月 因为公司新的项目，人生第一次到武汉，周末闲暇之余肯定是要四处转转的😄 在酒店拍的窗外的高架桥，同一张照片调了2种颜色风格： 壕里壕气的甲方爸爸在南湖边的办公园区： emmm，不得不说武汉的天气是真的好，基本上都是蓝天白云，当然最美的还是傍晚湖边的晚霞 加班到深夜… 正午 这么好的阳光，不自拍一张可惜了，哈哈哈哈 逼格不够，黑白来凑😂 ","date":"2022-01-10","objectID":"/2021%E5%B9%B44%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年4月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B44%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年5月 没错，还没过完五一假期，就又马不停蹄的回到了武汉。。 这次换了个酒店，窗外的景色也就不一样了 中午吃饭的时候不经意抬头看到后马上掏出手机来了一张 吃完午饭回去路上再来一张，哈哈哈哈 加班加到差点晕倒，深夜挂了急诊输了一晚上的液，早上出院的时候先来了一碗热干面。emmmm… 果然是屋漏偏逢连夜雨，碗里吃出一个硕大的苍蝇遗体😭 ","date":"2022-01-10","objectID":"/2021%E5%B9%B45%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年5月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B45%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年6月 是的，我又又又来武汉了，还是出差。。🙁 南湖的晚霞算是一点点些许安慰吧（太喜欢这张了，所以忍不住多调了个黑白版的） 园区的花正艳 楼 云 线 中途回了一趟成都 跟家人聚了聚 然后，就又又又又飞武汉了…😶 ","date":"2022-01-10","objectID":"/2021%E5%B9%B46%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年6月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B46%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年7月 南湖的荷花开啦 来了这么多次，终于打卡了黄鹤楼😂 楼顶的视野是真的棒 网红机位😏 继续打卡打卡打卡 江汉路 坐了盘2块钱的轮渡，拍的这张最喜欢 长江大桥，忘了是几桥来着。。一桥？ 网红电视塔 夜景 湖北博物馆 当然还有勾践剑 当然还有曾侯乙编钟 忘了叫啥。。就觉得这个头很有神秘色彩 还是忘了叫啥。。 地铁站也不放过 南湖的晚霞真的是美炸 终于可以回家啦！！！ 虽然窗外下着雨，但心情很阳光 当然…高兴不了太久，回去没多久就又去了合肥。。。 （因为只呆了几天，就放在这里不另外开贴了） ","date":"2022-01-10","objectID":"/2021%E5%B9%B47%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年7月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B47%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["摄影","记录生活"],"content":"2021年9月 因为在武汉这边新招了人，所以过来的频率终于没那么高了 隔了这么久，没变的是这边的晚霞，还是那么好看 ","date":"2022-01-10","objectID":"/2021%E5%B9%B49%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/:1:0","tags":["摄影"],"title":"2021年9月-出差扫街记录之武汉篇","uri":"/2021%E5%B9%B49%E6%9C%88-%E5%87%BA%E5%B7%AE%E6%89%AB%E8%A1%97%E8%AE%B0%E5%BD%95%E4%B9%8B%E6%AD%A6%E6%B1%89%E7%AF%87/"},{"categories":["PinPoint"],"content":"简介 pinpoint是开源在github上的一款全链路APM监控工具，提供了无侵入式的调用链监控、方法执行详情查看、应用状态信息监控等功能。基于GoogleDapper论文进行的实现，与另一款开源的全链路分析工具Zipkin类似，但相比Zipkin提供了无侵入式、代码维度的监控等更多的特性。 Pinpoint支持的功能比较丰富，可以支持如下几种功能： 服务拓扑图： 对整个系统中应用的调用关系进行了可视化的展示，单击某个服务节点，可以显示该节点的 详细信息，比如当前节点状态、请求数量等 实时活跃线程图： 监控应用内活跃线程的执行情况，对应用的线程执行性能可以有比较直观的了解 请求响应散点图： 以时间维度进行请求计数和响应时间的展示，拖过拖动图表可以选择对应的请求查看执行的详细情况 请求调用栈查看： 对分布式环境中每个请求提供了代码维度的可见性，可以在页面中查看请求针对到代码维度的执行详情，帮助查找请求的瓶颈和故障原因。 应用状态、机器状态检查： 通过这个功能可以查看相关应用程序的其他的一些详细信息，比如CPU使用情况，内存状态、垃圾收集状态，TPS和JVM信息等参数。 总体来说，使用pinpoint的一些优点： 可以掌握系统的整体响应速度情况，对系统运行情况能比较清晰 可以掌握各节点的响应速度情况，比如第三方服务接口，redis，mysql等 可以掌握单次请求的具体服务链路耗时情况，定位性能瓶颈 单次请求的具体服务链路请求信息，对于排查问题能提供帮助 监控各服务的JVM、线程池、数据库连接池使用情况，尤其是对分布式服务系统来说 github地址： ​ 项目地址：https://github.com/pinpoint-apm/pinpoint 官方docker部署地址：https://github.com/pinpoint-apm/pinpoint-docker ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"架构组成 Pinpoint 主要由 3 个组件外加 Hbase 数据库组成，三个组件分别为：Agent、Collector 和 Web UI ​ Agent组件： 用于收集应用端监控数据，无侵入式，只需要在启动命令中加入部分参数即可 Collector组件： 数据收集模块，接收Agent发送过来的监控数据，并存储到HBase WebUI： 监控展示模块，展示系统调用关系、调用详情、应用状态等，并支持报警等功能 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"安装Collector组件 使用docker-compose安装最新版本： # 克隆官方的docker部署git git clone https://github.com/naver/pinpoint-docker.git # 进入clone的目录 cd pinpoint-docker # 使用docker-compose拉取镜像和运行服务。注意docker-compose是需要单独安装的 docker-compose pull \u0026\u0026 docker-compose up -d 如果想安装历史或指定版本，可以直接指定git tags： # 克隆官方的docker部署git git clone https://github.com/naver/pinpoint-docker.git # 进入clone的目录 cd pinpoint-docker # 使用git命令切换到指定版本的tag git checkout {tag} # 使用docker-compose拉取镜像和运行服务。注意docker-compose是需要单独安装的 docker-compose pull \u0026\u0026 docker-compose up -d 如果部署的时候想使用一些自定义配置，例如指定的端口，可以通过修改 docker-compose.yml 和 .env 中对应的配置来实现，建议优先通过修改.env文件来做自定义配置 修改端口可以直接修改.env文件，默认端口是Pinpoint-Web：8079，QuickStart：8000和Flink：8081 部署完成之后，使用docker-compose ps命令即可查看所有容器： 访问 http://xx.xx.xx.xx:8079/ 即可浏览pinpoint页面 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:3:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"安装配置Agent组件 从github中pinpoint的Release发布页面中下载和Collector组件版本一致的Agent程序包 将Agent程序包上传到需要监控的服务器上，解压压缩包，修改pinpoint.config配置文件，一般只需修改文件中的profiler.collector.ip=127.0.0.1为前面所部署的Collector组件所在IP地址 配置文件分为local和Release版本，选择任一一个修改即可，但是需要在pinpoint-root.config文件中指定对应的配置版本 如果在多台服务器上部署了应用，那么就需要在多台机器上部署Agent组件 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:4:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"配置监听应用 pinpoint的监控完全是无侵入式的，配置起来也很简单，只需要在java应用的启动命令增加几个参数即可： # ${pinpointPath}是agent组件存放的路径，类似于JAVA_HOME -javaagent:${pinpointPath}/pinpoint-bootstrap-2.3.1.jar #'dpccb'可自定义命名，在pinpoint页面上显示的名称 -Dpinpoint.applicationName=dpccb #id可自定义命名，可以和Name一样 -Dpinpoint.agentId=dpccb 启动应用程序，打开应用页面访问一下，然后登陆pinpoint的Web页面即可看到相关的监控内容了 如果应用是通过容器方式运行的，也可以通过修改启动脚本和Dockerfile的方式来配置agent的监听 //修改启动命令 //把agent的存放目录挂载到应用的容器内 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:4:1","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"pinpoint功能介绍 详细使用教程可以参考这篇文章：pinpoint使用详解（图文版） ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:0","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"首页 选择一个需要查看的应用，即可在首页中以图形化的方式展示用户请求、服务间的调用关系等信息。另外还有响应时间分析图、调用散点图、响应时长分布、等待时长分布等。在右侧的调用统计图中用鼠标左键框选(如图上红框)即可查看选中部分的调用详情 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:1","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"调用详细信息 详情页，选择一个请求后下方会显示其详细信息，包含响应时间，请求过程中涉及的代码方法，sql语句等 选择混合视图后还可以同时查看调用树、服务器性能占用、server map等信息 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:2","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["PinPoint"],"content":"应用检查工具 查看应用的其他细节，如CPU使用、内存/垃圾收集、TPS和JVM参数 ","date":"2022-01-07","objectID":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:5:3","tags":["PinPoint","APM"],"title":"PinPoint安装配置","uri":"/pinpoint%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["Linux"],"content":" 新增atrandys大佬的一键安装脚本，支持centos7+/debian9+/ubuntu16+: wget --no-check-certificate https://raw.githubusercontent.com/cx9208/Linux-NetSpeed/master/tcp.sh chmod +x tcp.sh ./tcp.sh 新增Google原版BBR一键安装脚本： wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:0:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"BBR简介 BBR 是 Google 推出的一个「TCP 拥塞控制算法」，它是以 Linux 内核模块的形式加载，可以最大化 Linux Server 的网络吞吐量。 简单地说，开启 BBR 的 Linux Server 和不开启 BBR 的 Linux Server，在持续传输数据方面可以有非常大的不同。 BBR 尽管还没有在主流发行版中默认开启，但 Google 已经在 YouTube 网站上实践了很久，可以说是很成熟的一样技术了。 ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:1:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"检测 BBR 是否开启 在开始之前，先看看 BBR 是否已经启用了，执行这条指令可以返回当前 Linux 内核可以使用的 TCP 拥堵控制算法： sysctl net.ipv4.tcp_available_congestion_control 例如，在我的Server上返回了如下内容： net.ipv4.tcp_available_congestion_control = cubic reno 可以看到是没有BBR的，因为默认的 Ubuntu 16.04 用的是 Linux 4.4.0 内核，所以自然是看不到 BBR 的。 我们再次确认下系统当前启用的拥塞算法： sysctl net.ipv4.tcp_congestion_control 返回的内容是： net.ipv4.tcp_congestion_control = cubic 可以看到系统使用的是 cubic 这个默认的算法。接下去我们通过最标准的模式来为这台 Ubuntu 16.04 启用 BBR ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:2:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"为Ubuntu 16.04 安装/启用 BBR ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:3:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"安装 4.10+ 新内核 BBR 只能配合 Linux Kernel 4.10 以上内核才能使用。但是在 Ubuntu 16.04 上怎么使用 4.10 呢？难道要手动下载和安装吗？ 不能！这会有一个安全隐患，手动下载安装的新内核，无法保证后续能得到及时的安全更新。那么怎么办？这里推荐使用 HWE 版本的内核，它就在官方源里。 HWE，即：HareWare Enablement，是专门为在老的系统上支持新的硬件而推出的内核。你可以像安装其他软件包一样在 Ubuntu 16.04 里非常容易的安装它，只需要执行下面的命令： sudo apt-get install linux-generic-hwe-16.04 对！只需要这样就OK了！ 安装好以后重启系统，然后输入： uname -a 我的Server输出如下： Linux oneone 4.15.0-74-generic #83~16.04.1-Ubuntu SMP Wed Dec 18 04:56:23 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 可以看到系统内核已经升级到4.15.0了。 ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:3:1","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"启用 BBR 接下来就可以为新内核装载 BBR 模块了，分别执行： sudo modprobe tcp_bbr echo \"tcp_bbr\" | sudo tee -a /etc/modules-load.d/modules.conf 接下来我们再来查看系统支持的拥塞算法，可以看到BBR已经在里面了： root@oneone:~# sysctl net.ipv4.tcp_available_congestion_control net.ipv4.tcp_available_congestion_control = reno cubic bbr 接下来就正式启用BBR，把它设为系统的默认拥塞算法，分别执行： echo \"net.core.default_qdisc=fq\" | sudo tee -a /etc/sysctl.conf echo \"net.ipv4.tcp_congestion_control=bbr\" | sudo tee -a /etc/sysctl.conf sudo sysctl -p 最后，再来验证一下是否设置成功，可以看到BBR已经是默认算法： root@oneone:~# sysctl net.ipv4.tcp_congestion_control net.ipv4.tcp_congestion_control = bbr ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:3:2","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"为Centos7 安装/启用 BBR ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:4:0","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"安装 4.10+ 新内核 先查看系统版本： cat /etc/redhat-release #例如我的系统版本是7.6，输出如下: CentOS Linux release 7.6.1810 (Core) 添加elrepo源，然后升级内核，操作命令如下： #添加、更新源 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm #安装内核 yum --enablerepo=elrepo-kernel install kernel-ml -y 安装完成后，可以使用下方的命令查看系统已经安装了内核 awk -F\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /etc/grub2.cfg #例如我的系统查询结果如下，其中‘5.5.8’版本的内核是刚刚安装的： 0 : CentOS Linux (5.5.8-1.el7.elrepo.x86_64) 7 (Core) 1 : CentOS Linux (4.14.129-bbrplus) 7 (Core) 2 : CentOS Linux (0-rescue-05cb8c7b39fe0f70e3ce97e5beab809d) 7 (Core) 接着我们就把刚安装的CentOS Linux (5.5.8-1.el7.elrepo.x86_64) 7 (Core)内核设置为默认： grub2-set-default 0 设置完默认内核之后，使用uname -a查看时发现当前使用的内核还是之前的版本，这是因为切换内核后需要重启系统才能生效： #查看还是之前的版本： [root~]# uname -a Linux ip-172-31-21-55.ap-southeast-1.compute.internal 4.14.129-bbrplus #1 SMP Tue Jun 25 12:23:41 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux #重启系统即可生效 [root@~]# reboot ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:4:1","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"启用 BBR 编辑sysctl.conf文件，并添加如下内容： # 使用vim编辑文件 vim /etc/sysctl.conf #在文件中添加如下内容并保存： net.core.default_qdisc = fq net.ipv4.tcp_congestion_control = bbr 加载系统参数，并确认配置是否生效，如果生效会打印上方刚刚新增的内容： sysctl -p 最后，再次验证一下是否设置成功： [root@~]# sysctl net.ipv4.tcp_congestion_control #输出如下，则表示默认加速算法已经是bbr net.ipv4.tcp_congestion_control = bbr ","date":"2020-03-07","objectID":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/:4:2","tags":["科学上网"],"title":"在Ubuntu16.04和Centos7上启用TCP-BBR","uri":"/%E5%9C%A8ubuntu16.04%E5%92%8Ccentos7%E4%B8%8A%E5%90%AF%E7%94%A8tcp-bbr/"},{"categories":["Linux"],"content":"用法: grep [选项]… PATTERN [FILE]… 在每个 FILE 或是标准输入中查找 PATTERN。 默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。 例如: grep -i 'hello world' menu.h main.c 正则表达式选择与解释: -E, --extended-regexp PATTERN 是一个可扩展的正则表达式(缩写为 ERE) -F, --fixed-strings PATTERN 是一组由断行符分隔的字符串。 -G, --basic-regexp PATTERN 是一个基本正则表达式(缩写为 BRE) -P, --perl-regexp PATTERN 是一个 Perl 正则表达式 -e, --regexp=PATTERN 用 PATTERN 来进行匹配操作 -f, --file=FILE 从 FILE 中取得 PATTERN -i, --ignore-case 忽略大小写 -w, --word-regexp 强制 PATTERN 仅完全匹配字词 -x, --line-regexp 强制 PATTERN 仅完全匹配一行 -z, --null-data 一个 0 字节的数据行，但不是空行 杂项: -s, --no-messages 不显示错误信息 -v, --invert-match 选中不匹配的行 -V, --version 显示版本信息并退出 --help 显示此帮助并退出 输出控制: -m, --max-count=NUM NUM 次匹配后停止 -b, --byte-offset 输出的同时打印字节偏移 -n, --line-number 输出的同时打印行号 --line-buffered 每行输出清空 -H, --with-filename 为每一匹配项打印文件名 -h, --no-filename 输出时不显示文件名前缀 --label=LABEL 将LABEL 作为标准输入文件名前缀 -o, --only-matching 只显示匹配PATTERN 部分的行 -q, --quiet, --silent 不显示所有常规输出 --binary-files=TYPE 设定二进制文件的TYPE 类型； TYPE 可以是`binary', `text', 或`without-match' -a, --text 等同于 --binary-files=text -I 等同于 --binary-files=without-match -d, --directories=ACTION 读取目录的方式； ACTION 可以是`read', `recurse',或`skip' -D, --devices=ACTION 读取设备、先入先出队列、套接字的方式； ACTION 可以是`read'或`skip' -r, --recursive 等同于--directories=recurse -R, --dereference-recursive 同上，但遍历所有符号链接 --include=FILE_PATTERN 只查找匹配FILE_PATTERN 的文件 --exclude=FILE_PATTERN 跳过匹配FILE_PATTERN 的文件和目录 --exclude-from=FILE 跳过所有除FILE 以外的文件 --exclude-dir=PATTERN 跳过所有匹配PATTERN 的目录。 -L, --files-without-match 只打印不匹配FILEs 的文件名 -l, --files-with-matches 只打印匹配FILES 的文件名 -c, --count 只打印每个FILE 中的匹配行数目 -T, --initial-tab 行首tabs 分隔（如有必要） -Z, --null 在FILE 文件最后打印空字符 文件控制: -B, --before-context=NUM 打印文本及其前面NUM 行 -A, --after-context=NUM 打印文本及其后面NUM 行 -C, --context=NUM 打印NUM 行输出文本 -NUM 等同于 --context=NUM --color[=WHEN], --colour[=WHEN] 使用标记高亮匹配字串； WHEN 可以是`always', `never'或`auto' -U, --binary 不要清除行尾的CR 字符(MSDOS/Windows) -u, --unix-byte-offsets 忽略CR 字符，报告字节偏移 (MSDOS/Windows) egrep 即grep -E。fgrep 即grep -F。 直接调用egrep 或是fgrep 均已被废弃。 若FILE 为 -，将读取标准输入。不带FILE，读取当前目录，除非命令行中指定了-r 选项。 如果少于两个FILE 参数，就要默认使用-h 参数。 如果有任意行被匹配，那退出状态为 0，否则为 1； 如果有错误产生，且未指定 -q 参数，那退出状态为 2。 ","date":"2020-02-26","objectID":"/grep/:0:0","tags":["Linux"],"title":"grep","uri":"/grep/"},{"categories":["Linux"],"content":"下面内容对应环境为：Ubuntu 16.04 首先放一张根目录下的文件夹图 boot 该文件夹存放引导加载器(bootstrap loader)使用的文件,一般我们不会使用这里面的文件 dev 该文件夹存放的是设备文件即设备驱动程序,用户可以通过这些文件访问外部设备. /dev/null称为空设备,也称为位桶（bit bucket）或者黑洞(black hole),你可以向它输入任何数据，但任何写入它的数据都会被抛弃。通常用于处理不需要的输出流,这些操作通常由重定向完成 /dev/shm/这个目录是linux下一个利用内存虚拟出来的一个目录,这个目录中的文件都是保存在内存中，而不是磁盘上。其大小是非固定的，即不是预先分配好的内存来存储的。(shm == shared memory). 默认最大为内存的一半大小，使用df -h命令可以看到.但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节 我们可以看到/dev/shm的文件系统为tmpfs，即为临时文件系统 home 该文件夹包含用户家目录，即系统上的所有实际数据存放的地方,你添加的用户 都会在该目录下创建一个和用户们相同的目录,为该用户的家目录 root 超级管理员的家目录 bin /bin目录包含了引导启动所需的命令和普通用户可能用的命令.这些命令都是二进制文件的可执行程序(bin是binary的简称)，多是系统中重要的系统文件 sbin /sbin目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用 etc /etc目录存放着各种系统配置文件，其中包括了用户信息文件/etc/passwd， 系统初始化文件/etc/rc等。linux正是靠这些文件才得以正常地运行 lib /lib目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件,这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本,故可以使得可执行文件变得更小,节省空间. tmp 临时目录,对于某些程序来说,有些文件被用了一次两次之后,就不会再被用到,像这样的文件就放在这里.有些linux系统会定期自动对这个目录进行清理，因此，千万不要把重要的数据放在这里 opt 这个目录主要存那些可选的程序.想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候,你就可以直接删除它，而不影响系统其他任何设置.安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面 举例:刚才装的测试版firefox,就可以装到/opt/firefox_beta目录下,/opt/firefox_beta目录下面就包含了运行firefox所需要的所有文件、库、数据等等.要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单 usr /usr是个很重要的目录,因为所有程序安装在这里. /usr/local:本地安装的程序和其他东西，因为这样可以在升级新版系 统或新发行版时无须重新安装全部程序 /usr/bin:集中了几乎所有用户命令，是系统的软件库.另有些命令在/bin或/usr/local/bin中 /usr/sbin:包括了根文件系统不必要的系统管理命令 /usr/src:linux内核的源代码 var /var包含系统一般运行时要改变的数据,通常这些数据所在的目录的大小是要经常变化或扩充的 /var/lib：存放系统正常运行时要改变的文件 /var/local：存放/usr/local中安装的程序的可变数据 /var/log:各种程序的日志(log)文件,这里的文件经常不确定地增长,应该定期清除。 /var/tmp：比/tmp允许更大的或需要存在较长时间的临时文件 proc /proc文件系统是一个伪的文件系统,就是说它是一个实际上不存在的目录,因而这是一个非常特殊的目录.它并不存在于某个磁盘上,而是由核心在内存中产生.这个目录用于提供关于系统的信息 /proc/x:关于进程x的信息目录,这x是这一进程的标识号.每个进程在 /proc下有一个名为自己进程号的目录 /proc/cpuinfo:存放处理器(cpu)的信息，如cpu的类型、制造商、 型号和性能等 /proc/filesystems:核心配置的文件系统信息 /proc/uptime:系统启动的时间长度 /proc/version:核心版本 lost+found 这个目录平时是空的,系统非正常关机而留下“无家可归”的文件就在这里 ","date":"2020-02-25","objectID":"/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/:0:0","tags":["Linux"],"title":"Linux下各文件夹的作用","uri":"/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/"},{"categories":["Linux","vim"],"content":"在使用vim时，当我们以普通用户去打开一个只有root用户才有权限操作的文件时，我们编辑完成之后，正要保存，却发现，这个文件我们没有权限修改。 经过查找，发现一个命令可以解决这个问题 命令： :w !sudo tee % w： 表示保存文件 ！： 表示执行外部命令 tee： linux命令，这个有点复杂，可以查看linux命令帮助 %： 在执行外部命令时，%会扩展成当前文件名；这个%区别于替换时的%，替换时%的意义是代表整个文件，而不是文件名 此命令是把当前文件（即%）作为stdin传给sudo tee命令来执行。说起来挺绕口，其实就是：用sudo强制保存。 这行命令解决了不能保存只读文件的问题，但毕竟命令还是有些长，为了避免每次输入一长串的命令，可以将它映射为一个简单的命令加到 .vimrc 中： \" Allow saving of files as sudo when I forgot to start vim using sudo. cmap w!! w !sudo tee \u003e /dev/null % 这样，简单的运行:w!!即可。命令后半部分\u003e /dev/null作用为显式的丢掉标准输出的内容。 ","date":"2020-02-25","objectID":"/vim%E6%9D%83%E9%99%90%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BC%BA%E5%88%B6%E4%BF%9D%E5%AD%98%E5%8F%AA%E8%AF%BB%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["vim"],"title":"Vim权限不足时强制保存只读类型文件的方法","uri":"/vim%E6%9D%83%E9%99%90%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BC%BA%E5%88%B6%E4%BF%9D%E5%AD%98%E5%8F%AA%E8%AF%BB%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["软件测试","Jmeter"],"content":"脚本规范： 目录结构按系统级别区分不同的jmx文件，每个系统一个jmx文件进行管理 线程组作为模块级别，命名格式为模块名称 接口作为用例级别，命名格式类似为 ： 【编号】 【正例/反例】用例名称 使用用户定义的变量将系统中使用到的全局变量抽取到全局自定义变量中，只支持抽取整个系统公用变量 使用用户定义的变量将模块中使用到的测试数据抽取到局部自定义变量中 每个接口都需要增加断言，保证脚本的结果的正确性 尽量将环境变量抽取到全局中，方便环境切换 提交测试脚本时尽量删除自己创建的垃圾数据 ","date":"2020-02-25","objectID":"/jmeter/:0:0","tags":["Jmeter"],"title":"Jmeter","uri":"/jmeter/"},{"categories":["Linux"],"content":"系统 uname -a** 查看内核/操作系统/CPU信息 head -n 1 /etc/issue 查看操作系统版本 *cat /proc/cpuinfo 查看CPU信息 hostname** 查看计算机名 lspci -tv 列出所有PCI设备 lsusb -tv 出所有USB设备 lsmod 列出加载的内核模块 env 查看环境变量 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"资源 free -m 查看内存使用量和交换区使用量 df -h 查看各分区使用情况 du -sh \u003c目录名\u003e 查看指定目录的大小 grep MemTotal /proc/meminfo 查看内存总量 grep MemFree /proc/meminfo 查看空闲内存量 uptime 查看系统运行时间、用户数、负载 cat /proc/loadavg 查看系统负载 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"磁盘和分区 mount | column -t 查看挂接的分区状态 fdisk -l 查看所有分区 swapon -s 查看所有交换分区 hdparm -i /dev/hda 查看磁盘参数(仅适用于IDE设备) dmesg | grep IDE 查看启动时IDE设备检测状况 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"网络 ifconfig 查看所有网络接口的属性 iptables -L 查看防火墙设置 route -n 查看路由表 netstat -lntp 查看所有监听端口 netstat -antp 查看所有已经建立的连接 netstat -s 查看网络统计信息 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"进程 ps -ef 查看所有进程 top 实时显示进程状态 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"用户 w 查看活动用户 id \u003c用户名\u003e 查看指定用户信息 last 查看用户登录日志 cut -d: -f1 /etc/passwd 查看系统所有用户 cut -d: -f1 /etc/group 查看系统所有组 crontab -l 查看当前用户的计划任务 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"服务 chkconfig –list 列出所有系统服务 chkconfig –list | grep on 列出所有启动的系统服务 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"程序 apt-get update 在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。 apt-get install packagename 安装一个新软件包（参见下文的aptitude） apt-get remove packagename 卸载一个已安装的软件包（保留配置文件） apt-get –purge remove packagename 卸载一个已安装的软件包（删除配置文件） dpkg –force-all –purge packagename 有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。 apt-get autoclean apt 会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件 apt-get clean 这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。 apt-get upgrade 更新所有已安装的软件包 apt-get dist-upgrade 将系统升级到新版本 apt-cache search string 在软件包列表中搜索字符串 dpkg -l package-name-pattern 列出所有与模式相匹配的软件包。如果您不知道软件包的全名，您可以使用“package-name-pattern”。 aptitude 详细查看已安装或可用的软件包。与apt-get类似，aptitude可以通过命令行方式调用，但仅限于某些命令——最常见的有安装和卸载命令。由于aptitude比apt-get了解更多信息，可以说它更适合用来进行安装和卸载。 apt-cache showpkg pkgs 显示软件包信息。 apt-cache dumpavail 打印可用软件包列表。 apt-cache show pkgs 显示软件包记录，类似于dpkg –print-avail。 apt-cache pkgnames 打印软件包列表中所有软件包的名称。 dpkg -S file 这个文件属于哪个已安装软件包。 dpkg -L package 列出软件包中的所有文件。 apt-file search filename 查找包含特定文件的软件包（不一定是已安装的），这些文件的文件名中含有指定的字符串。 apt-file 是一个独立的软件包。您必须 先使用apt-get install来安装它，然后运行apt-file update。如果apt-file search filename 输出的内容太多，您可以尝试使用apt-file search sfilename | grep -w filename s（只显示指定字符串作为完整的单词出现在其中的那些文件名）或者类似方法，例如：apt-file search filename | grep /bin/（只显示位于诸如/bin或/usr/bin这些文件夹中的文件，如果您要查找的是某个特定的执行文件的话，这样做是有帮助的）。 ","date":"2020-02-24","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"问题现象 ​ 按照网上配置java环境变量的方法在/etc/profile文件中添加如下内容，配置之后，如果重启系统后切换到root用户无法获取已配置的java环境变量，在普通用户下可以获取到 export JAVA_HOME=/usr/local/java/jdk1.8.0_65 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH ","date":"2020-02-24","objectID":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:1:0","tags":["Linux"],"title":"Ubuntu root用户下java -version无法获取java环境变量解决办法","uri":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["Linux"],"content":"解决办法 sudo ln -s /你的jdk路径/bin/jar /bin/jar sudo ln -s /你的jdk路径/bin/java /bin/java sudo ln -s /你的jdk路径/bin/javac /bin/javac sudo ln -s /你的jdk路径/bin/javah /bin/javah sudo ln -s /你的jdk路径/bin/javadoc /bin/javadoc ","date":"2020-02-24","objectID":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:2:0","tags":["Linux"],"title":"Ubuntu root用户下java -version无法获取java环境变量解决办法","uri":"/ubuntu-root%E7%94%A8%E6%88%B7%E4%B8%8Bjava-version%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["Linux","oh-my-zsh"],"content":"如果使用wt用户安装配置了oh-my-zsh，其他用户想要使用相同的主题和配置，可以参考https://askubuntu.com/questions/521469/oh-my-zsh-for-the-root-and-for-all-user 这里介绍一种更简单的方法（亲测有效）： 比如让root用户使用和wt用户相同的配置： sudo ln -s $HOME/.oh-my-zsh /root/.oh-my-zsh sudo ln -s $HOME/.zshrc /root/.zshrc 切换到root用户，命令zsh,即可看到zsh的主题和wt用户的一样了。如果提示 /root/.zshrc:119: command not found: pyenv /root/.zshrc:120: command not found: pyenv 再创建.pyenv的软连接即可。 sudo ln -s $HOME/.pyenv /root/.pyenv 这样做的缺点是root用户的所有配置都和wt用户的一致，不能个性化。修改一个，其他用户的也会变。 如果要个性化，可以用 sudo cp -r /home/wt/.oh-my-zsh /root sudo cp -r /home/wt/.zshrc /root ","date":"2020-02-24","objectID":"/%E8%AE%A9%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8oh-my-zsh/:0:0","tags":["oh-my-zsh"],"title":"让其他用户使用oh-my-zsh","uri":"/%E8%AE%A9%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8oh-my-zsh/"},{"categories":["Linux","Docker"],"content":" docker 服务重启，关闭，启动及版本查看 [root@localhost /] systemctl restart docker.service #重启服务 [root@localhost /] systemctl stop docker.service #关闭服务 [root@localhost /] systemctl start docker.service #启动服务 [root@iZm5e3hwzuo58e05kxjiifZ /] docker -v #docker版本查看 Docker version 18.06.1-ce, build e68fc7a docker 搜索/下载/查看镜像 [root@localhost /] docker search centos|head -3 #搜索镜像 NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 4754 [OK] [root@localhost /] docker pull centos #下载镜像 Using default tag: latest............. Digest: sha256:6f6d986d425aeabdc3a02cb61c02abb2e78e57357e92417d6d58332856024faf Status: Downloaded newer image for centos:latest [root@localhost /] docker images #查看镜像 REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5182e96772bf 7 weeks ago 200MB docker 创建一个容器（前台/后台并指定映射目录和端口） -i：允许我们对容器内的 (STDIN) 进行交互 -t：在新容器内指定一个伪终端或终端 -v：是挂在宿机目录， /docker_test是宿机目录，/yufei是当前docker容器的目录，宿机目录必须是绝对的。 --name：是给容器起一个名字，可省略，省略的话docker会随机产生一个名字 -P 指定映射的端口 --net #指定网络 --link 链接到另一个容器 -------------------------------------------------------------------------------------------------- docker run -it -v /test:/test --name centos /bin/bash #创建容器并进入（交互模式退出会后容器会自动关闭） docker run -d -v /test:/test centos tail -f /dev/null #创建容器并放入后台运行（退出容器不会关闭） docker run -dit -v /test:/test centos /bin/bash #创建容器并放入后台运行（进入后台和tty模式，退出容器不会关闭） docker run -d -v /test:/test -P 80:80 nginx:latest #后台启动并运名为nginx的容器，然后将容器的80端口映射到物理机的80端口. 查看docker创建的所有容器 [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker ps -a #查看所有创建的容器包括已经停止的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 70e151cd2766 centos “/bin/bash” 7 seconds ago Exited (0) 5 seconds ago zealous_mclean dfdf33852d47 centos “/bin/bash” 20 seconds ago Up 19 seconds frosty_saha [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker ps #查看所有运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dfdf33852d47 centos “/bin/bash” 22 seconds ago Up 21 seconds frosty_saha [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker ps -l #查看最新创建的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 70e151cd2766 centos “/bin/bash” 29 minutes ago Exited (0) 29 minutes ago zealous_mclean ``` docker 利用已存在的容器创建一个镜像（Dockerfile构建镜像略） -a #提交的镜像作者 -c #使用Dockerfile指令来创建镜像 -m #提交时附上说明文字 -p #在commit时，将容器暂停 ------------------------------------------------------------------------------------------- [root@iZm5e3hwzuo58e05kxjiifZ ~] docker commit -a \"王云龙\" -m \"创建的新镜像\" redis wyl5588redis-test sha256:9c2d2fc6e09cb35543fbb2467db90e741dc6b7daabab83924534bcfe6641bbe2 [root@iZm5e3hwzuo58e05kxjiifZ ~] docker images REPOSITORY TAG IMAGE ID CREATED SIZE wyl5588redis-test latest 9c2d2fc6e09c 3 seconds ago 83.4MB docker 修改镜像标签，并推送 [root@iZm5e3hwzuo58e05kxjiifZ Dockerfile] docker tag centos 192.168.8.88:5000/centos:v1.0 #给centos镜像打一个行的tag [root@iZm5e3hwzuo58e05kxjiifZ Dockerfile] docker images REPOSITORY TAG IMAGE ID CREATED SIZE 192.168.8.88:5000/centos v1.0 5182e96772bf 7 weeks ago 200MB centos latest 5182e96772bf 7 weeks ago 200MB [root@iZm5e3hwzuo58e05kxjiifZ Dockerfile]docker push 192.168.8.88:5000/centos:v1.0 #将本地docker中的镜像推送到镜像仓库中 docker镜像的导入，导出，删除 docker save 5588/mongo3.2 5588/redis 5588/nginx 5588/qiantai \u003eQiantai_images.tar #镜像导出 docker load \u003c/Docker_Images/Qiantai.images.tar #镜像导入 docker rmi centos #删除centos镜像 docker rmi -f centos #强制删除 docker images -q #获取进行的ID docker rmi -f $(docker images -q)#删除全部镜像 docker 容器与宿主机文件拷贝 [root@iZm5e3hwzuo58e05kxjiifZ ~] touch admin [root@iZm5e3hwzuo58e05kxjiifZ ~] docker cp ./admin nginx:/tmp/ [root@iZm5e3hwzuo58e05kxjiifZ ~] docker exec -it nginx /bin/bash root@aaefa2aebc8b:/ ls /tmp admin root@aaefa2aebc8b:/ touch /tmp/wyltest exit [root@iZm5e3hwzuo58e05kxjiifZ ~] docker cp -a nginx:/tmp/wyltest ./ Error: No such container:path: nginx:/tmp/* [root@iZm5e3hwzuo58e05kxjiifZ ~] docker cp -a nginx:/tmp/admin ./ 查看docker 容器详情如：ip等 [root@iZm5e3hwzuo58e05kxjiifZ rc.d] docker inspect frosty_saha #查看容器详情如ip等frosty_saha为容器别名 [ { “Id”: “dfdf33852d470d0cd8e70a4b9aad36a00585579952834471159100aacea885d9”, “Created”: “2018-09-28T0","date":"2020-02-24","objectID":"/docker-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:0:0","tags":["Linux","Docker"],"title":"Docker-常用基础命令","uri":"/docker-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux","vim"],"content":"自用的vimrc配置文件备份: \" encoding dectection set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 \" Set vundle settings here \" git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim set nocompatible \" be iMproved, required filetype off \" required \" set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \" alternatively, pass a path where Vundle should install plugins \"call vundle#begin('~/some/path/here') \" let Vundle manage Vundle, required \"Plugin 'VundleVim/Vundle.vim' \"https://github.com/VundleVim/Vundle.vim Bundle 'Valloric/YouCompleteMe' Plugin 'gmarik/Vundle.vim' \" Custom plugins Plugin 'scrooloose/nerdtree' \"https://github.com/scrooloose/nerdtree Plugin 'MattesGroeger/vim-bookmarks' \"https://github.com/MattesGroeger/vim-bookmarks Plugin 'maciakl/vim-neatstatus' \"https://github.com/maciakl/vim-neatstatus \" All of your Plugins must be added before the following line call vundle#end() \" required filetype plugin indent on \" required \" To ignore plugin indent changes, instead use: \"filetype plugin on \" \" Brief help \" :PluginList - lists configured plugins \" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate \" :PluginSearch foo - searches for foo; append `!` to refresh local cache \" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal \" \" see :h vundle for more details or wiki for FAQ \" Put your non-Plugin stuff after this line \" Vim5 and later versions support syntax highlighting. Uncommenting the \" following enables syntax highlighting by default. if has(\"syntax\") syntax on \" 语法高亮 endif \" Uncomment the following to have Vim jump to the last position when \" reopening a file if has(\"autocmd\") au BufReadPost * if line(\"'\\\"\") \u003e 1 \u0026\u0026 line(\"'\\\"\") \u003c= line(\"$\") | exe \"normal! g'\\\"\" | endif \"have Vim load indentation rules and plugins according to the detected \"filetype on \"filetype plugin indent on endif set number set autoindent set softtabstop=4 \" 设置软制表符的宽度 set shiftwidth=4 \" (自动) 缩进使用的4个空格 set tabstop=4 \" 设置制表符(tab键)的宽度 set expandtab \" 行首tab转换为4个空格 set cindent \" 使用 C/C++ 语言的自动缩进方式 set cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,\u003e1s,=1s,:1s \"设置C/C++语言的具体缩进方式 set showmatch \" 设置匹配模式，显示匹配的括号 set linebreak \" 整词换行 set whichwrap=b,s,\u003c,\u003e,[,] \" 光标从行首和行末时可以跳到另一行去 set ruler \" 标尺，用于显示光标位置的行号和列号，逗号分隔。每个窗口都有自己的标尺。如果窗口有状态行，标尺在那里显示。否则，它显示在屏幕的最后一行上 set showcmd \" 命令行显示输入的命令 set showmode \" 命令行显示vim当前模式 set incsearch \" 输入字符串就显示匹配点 set hlsearch set enc=utf-8 \" 文件编码 set cursorline set cursorcolumn highlight CursorLine cterm=NONE ctermbg=blue ctermfg=white guibg=NONE guifg=NONE \"highlight CursorColumn cterm=NONE ctermbg=green ctermfg=NONE guibg=NONE guifg=NONE highlight CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white \" NERDTree settings autocmd StdinReadPre * let s:std_in=1 autocmd VimEnter * if argc() == 0 \u0026\u0026 !exists(\"s:std_in\") | NERDTree | endif \" vim-bookmarks settings let g:bookmark_auto_close = 1 let g:bookmark_save_per_working_dir = 1 let g:bookmark_highlight_lines = 1 let g:bookmark_center = 1 let g:bookmark_location_list = 1 \" key mapping :inoremap { {}\u003cESC\u003ei :map \u003cf2\u003e :NERDTreeToggle\u003cCR\u003e ","date":"2020-02-24","objectID":"/vimrc-%E5%A4%87%E4%BB%BD/:0:0","tags":["vim","Linux"],"title":".vimrc-备份","uri":"/vimrc-%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"\r\r404\r\r\r\r\r\r","date":"0001-01-01","objectID":"/404/:0:0","tags":null,"title":"404","uri":"/404/"},{"categories":["Linux"],"content":"有时候，在Linux系统中rm删除文件后，使用df查看空间占用情况时会发现，占用空间并没有减少。这往往都是因为被删除的文件还被某些进程占用着，从而导致文件已经删除了但是空间并没有真正的释放。 这时可以使用下面的命令查看，有哪些进程占用着被删除文件： lsof | grep deleted 最后，就可以通过杀掉这些进程的方式时系统可以回收空间，命令如下： lsof | grep delete | xargs kill -s 9 ","date":"0001-01-01","objectID":"/linux%E4%B8%8A%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%90%8E%E7%A9%BA%E9%97%B4%E6%B2%A1%E6%9C%89%E8%A2%AB%E9%87%8A%E6%94%BE/:0:0","tags":["Linux"],"title":"Linux上删除文件后空间没有被释放","uri":"/linux%E4%B8%8A%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%90%8E%E7%A9%BA%E9%97%B4%E6%B2%A1%E6%9C%89%E8%A2%AB%E9%87%8A%E6%94%BE/"},{"categories":["Linux"],"content":"Linux 系统启动过程linux启动时我们会看到许多启动信息。 Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段： 内核的引导。 运行 init。 系统初始化。 建立终端 。 用户登录系统。 init程序的类型： SysV: init, CentOS 5之前, 配置文件： /etc/inittab。 Upstart: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。 Systemd： systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。 ","date":"0001-01-01","objectID":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:0:0","tags":["Linux"],"title":"Linux系统启动过程","uri":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":["Linux"],"content":"内核引导 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。 操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。 ","date":"0001-01-01","objectID":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:1:0","tags":["Linux"],"title":"Linux系统启动过程","uri":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":["Linux"],"content":"运行init init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。 init 程序首先是需要读取配置文件 /etc/inittab。 ","date":"0001-01-01","objectID":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:2:0","tags":["Linux"],"title":"Linux系统启动过程","uri":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":["Linux"],"content":"运行级别 许多程序需要开机启动。它们在Windows叫做\"服务\"（service），在Linux就叫做\"守护进程\"（daemon）。 init进程的一大任务，就是去运行这些开机启动的程序。 但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。 Linux允许为不同的场合，分配不同的开机启动程序，这就叫做\"运行级别\"（runlevel）。也就是说，启动时根据\"运行级别\"，确定要运行哪些程序。 Linux系统有7个运行级别(runlevel)： 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 ##系统初始化 在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。 它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。 l5:5:wait:/etc/rc.d/rc 5 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。 而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。 /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。 而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。 这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。 至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的\"System Services\"来自行设定。 ","date":"0001-01-01","objectID":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:3:0","tags":["Linux"],"title":"Linux系统启动过程","uri":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":["Linux"],"content":"建立终端 rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。 init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端： 1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6 从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。 同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。 ##用户登录系统 一般来说，用户的登录方式有三种： （1）命令行登录 （2）ssh登录 （3）图形界面登录 对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。 而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。 Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。 然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。 这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。 /etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。 ","date":"0001-01-01","objectID":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:4:0","tags":["Linux"],"title":"Linux系统启动过程","uri":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":["Linux"],"content":"图形模式与文字模式的切换方式 Linux预设提供了六个命令窗口终端机让我们来登录。 默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。 如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。 当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。 如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。 ","date":"0001-01-01","objectID":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:5:0","tags":["Linux"],"title":"Linux系统启动过程","uri":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":["Linux"],"content":"Linux 关机 在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 正确的关机流程为：sync \u003e shutdown \u003e reboot \u003e halt 关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。 例如你可以运行如下命令关机： sync #将数据由内存同步到硬盘中。 shutdown #关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机： shutdown –h 10 ‘This server will shutdown after 10 mins’ #这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。 shutdown –h now #立马关机 shutdown –h 20:25 #系统会在今天20:25关机 shutdown –h +10 #十分钟后关机 shutdown –r now #系统立马重启 shutdown –r +10 #系统十分钟后重启 reboot #就是重启，等同于 shutdown –r now halt #关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。 关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。 ","date":"0001-01-01","objectID":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/:6:0","tags":["Linux"],"title":"Linux系统启动过程","uri":"/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"categories":["NTP","Network"],"content":"一.概述 NTP (Network Time Protocol, 网络时间协议) 是由 RFC 5905 定义的时间同步协议, 用来在分布式时间服务器和客户端之间进行时间同步, 是一个跨越广域网或局域网的复杂的同步时间协议, 它通常可获得毫秒级的精度. NTP 基于 UDP 报文进行传输, 使用的UDP端口号为 123. 使用 NTP 的目的是对网络内所有具有时钟的设备进行时钟同步, 使网络内所有设备的时钟保持一致, 从而使设备能够提供基于统一时间的多种应用. 对于运行 NTP 的本地系统, 既可以接收来自其他时钟源的同步, 又可以作为时钟源同步其他的时钟, 并且可以和其他设备相互同步. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:1:0","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"二.工作原理 ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:2:0","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"实现方式 无线时钟: 服务器系统可以通过串口连接一个无线时钟. 无线时钟接收 GPS 的卫星发射的信号来决定当前时间. 无线时钟是一个非常精确的时间源, 但是需要花一定的费用. 时间服务器: 还可以使用网络中 NTP 时间服务器, 通过这个服务器来同步网络中的系统的时钟. 局域网内的同步: 如果只是需要在本局域网内进行系统间的时钟同步, 那么就可以使用局域网中任何一个系统的时钟. 你需要选择局域网中的一个节点的时钟作”权威的”的时间源, 然后其它的节点就只需要与这个时间源进行时间同步即可. 使用这种方式, 所有的节点都会使用一个公共的系统时钟, 但是不需要和局域网外的系统进行时钟同步. 如果一个系统在一个局域网的内部, 同时又不能使用无线时钟, 这种方式是最好的选择. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:2:1","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"工作流程 Device A 和 Device B 通过网络相连, 有自己独立的系统时钟, 通过 NTP 实现各自系统时钟的自动同步. Device A 和 Device B 的系统时钟同步之前, Device A 的时钟设定为 10:00:00 AM, Device B 的时钟设定为 11:00:00 AM. Device B 作为 NTP 时间服务器, 即 Device A 使自己的时钟与 Device B 时钟同步. NTP 报文在 Device A 和 Device B 之间单向传输所需要的时间为 1s. Device A 发送一个NTP报文给 Device B, 该报文带有它离开 Device A 时的时间戳, 该时间戳为 10:00:00 AM (T1). 当此 NTP 报文到达 Device B 时, Device B 加上自己的时间戳, 该时间戳为 11:00:01 AM (T2). 当此 NTP 报文离开 Device B 时, Device B 加上自己的时间戳, 该时间戳为 11:00:02 AM (T3). 当 Device A 接收到该响应报文时, Device A 的本地时间为 10:00:03 AM (T4). 至此, Device A 已经拥有足够的信息来计算两个重要的参数: NTP 报文的往返时延 Delay = (T4-T1) - (T3-T2) = 2s. Device A 相对 Device B 的时间差 Offset = ((T2-T1) + (T3-T4))/2 = 1h. 这样, Device A 就能够根据这些信息来设定自己的时钟, 使之与 Device B 的时钟同步. 设备可以采用多种 NTP 工作模式进行时间同步: 客户端/服务器模式 对称模式 广播模式 组播模式 ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:2:2","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"客户端/服务器模式 在客户端/服务器模式中, 客户端向服务器发送时钟同步报文, 报文中的 Mode 字段设置为3 (客户模式). 服务器端收到报文后会自动工作在服务器模式, 并发送应答报文, 报文中的 Mode 字段设置为4 (服务器模式). 客户端收到应答报文后, 进行时钟过滤和选择, 并同步到优选的服务器. 在该模式下, 客户端能同步到服务器, 而服务器无法同步到客户端. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:2:3","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"对称模式 在对称模式中, 主动对称体和被动对称体之间首先交互 Mode 字段为 3 (客户端模式) 和 4 (服务器模式) 的NTP报文. 之后, 主动对称体向被动对称体发送时钟同步报文, 报文中的 Mode 字段设置为 1 (主动对称体), 被动对等体收到报文后自动工作在被动对等体模式, 并发送应答报文, 报文中的Mode字段设置为 2 (被动对等体). 经过报文的交互, 对等体模式建立起来. 主动对等体和被动对等体可以互相同步. 如果双方的时钟都已经同步, 则以层数小的时钟为准. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:2:4","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"广播模式 在广播模式中, 服务器端周期性地向广播地址 255.255.255.255 发送时钟同步报文, 报文中的 Mode 字段设置为5 (广播模式). 客户端侦听来自服务器的广播报文. 当客户端接收到第一个广播报文后, 客户端与服务器交互 Mode 字段为3 (客户模式) 和 4 (服务器模式) 的NTP报文, 以获得客户端与服务器间的网络延迟. 之后, 客户端就进入广播客户端模式, 继续侦听广播报文的到来, 根据到来的广播报文对系统时钟进行同步. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:2:5","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"组播模式 在组播模式中, 服务器端周期性地向用户配置的组播地址 (若用户没有配置组播地址, 则使用默认的 NTP 组播地址224.0.1.1) 发送时钟同步报文, 报文中的 Mode 字段设置为 5 (组播模式). 客户端侦听来自服务器的组播报文. 当客户端接收到第一个组播报文后, 客户端与服务器交互 Mode 字段为 3 (客户模式) 和 4 (服务器模式) 的 NTP 报文, 以获得客户端与服务器间的网络延迟. 之后, 客户端就进入组播客户模式, 继续侦听组播报文的到来, 根据到来的组播报文对系统时钟进行同步. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:2:6","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"三.NTP报文格式 NTP 有两种不同类型的报文, 一种是 时钟同步报文, 一种是 控制报文. 控制报文 仅用于需要网络管理的场合, 对于时钟同步功能不是必需的, 暂不做分析. 时钟同步报文格式如下: LI (Leap Indicator): 闰秒标识器, 长度为 2 Bits, 用来预警最近一分钟插入 1s 或者删除 1s. LI Value 含义 00 0 无预告 01 1 醉经一分钟有 61s 10 2 最近一分钟有 59s 11 3 警告状态(时钟未同步) VN (Version Number): 版本号, 长度为 3 Bits, 目前最新的版本是 4, 向下兼容指定于 RFC 1305 的版本 3. Mode: 工作模式, 长度为 3 Bits. 点对点模式下, 客户端请求时设置此字段为 3, 服务器应答时设置此字段为 4. 广播模式下, 服务器应答设置此字段为 5. Mode Value 含义 000 0 保留 001 1 主动对称模式 010 2 被动对称模式 011 3 客户端模式 100 4 服务器模式 101 5 广播或组播模式 110 6 NTP控制报文 111 7 预留给内部使用 Stratum: 系统时钟的层数, 长度为 8 Bits, 取值范围 1~16, 定义时钟的准确度. 层数为 1 的时钟准确度最高, 准确度从 1 到 16 依次递减, 阶层的上限为15, 层数为 16的时钟处于未同步状态, 不能作为参考时钟. NTP 获得 UTC 的时间来源可以是原子钟, 天文台, 卫星, 也可以从Internet上获取. stratum-0 是高精度计时设备, 例如原子钟 (如铯, 铷), GPS时钟或其他无线电时钟. 它们生成非常精确的脉冲秒信号, 触发所连接计算机上的中断和时间戳. 也称为参考 (基准) 时钟. stratum-1 是与 stratum-0 设备相连, 在几微秒误差内同步系统时钟的计算机. 时间是按 NTP 服务器的等级传播. 按照距离外部 UTC 源的远近将所有服务器归入不同的 Stratum (层) 中. Stratum-1 在顶层, 有外部 UTC 接入, 而Stratum-2 则从 Stratum-1 获取时间, Stratum-3 从 Stratum-2 获取时间, 以此类推, 但 Stratum 层的总数限制在15以内. 所有这些服务器在逻辑上形成阶梯式的架构并相互连接, 而 Stratum-1 的时间服务器是整个系统的基础. stratum 含义 0 未指定或者难以获得 1 主要参考(如: 无线电时钟,校正的原子时钟) 2~15 第二参考(Via NTP) 16 未同步状态, 不能作为参考时钟 Poll: 轮询间隔时间, 长度为 8 Bits, 两个连续NTP报文之间的时间间隔, 用 2 的幂来表示, 比如值为 6 表示最小间隔为 2^6 = 64s. Precision: 系统时钟的精度, 长度为 8 Bits, 用 2 的幂来表示, 比如 50Hz(20ms)或者60Hz(16.67ms) 可以表示成值 -5 (2^-5 = 0.03125s = 31.25ms). Root Delay: 本地到主参考时钟源的往返时间, 长度为 32 Bits, 有 15～16 位小数部分的无符号定点小数. Root Dispersion: 系统时钟相对于主参考时钟的最大误差, 长度为 32 Bits, 有 15～16 位小数部分的无符号定点小数. 网络对称性: 通过两次测量来估计链路延迟一般估算方法是假设链路是对称的, 即时间服务器到客户端的延迟等于客户端到时间服务器的延迟. 这种假设是理想化的, 实际的无线链路往往受到各种因素影响, 例如 多径, 时变 而不完全对称. 网络的拓扑结构: 简单的点对点拓扑结构能达到较高的同步精度, 而一些复杂的网络容易受到网络延迟抖动的影响, 且精度与网络负载情况相关. Reference Identifier: 参考时钟源的标识, 长度为 32 Bits. Reference Timestamp: 系统时钟最后一次被设定或更新的时间, 长度为 64 Bits, 无符号定点数, 前 32 Bits 表示整数部分, 后 32 Bits 表示小数部分, 理论分辨率 2^−32s. 时间戳的记录以秒的形式从 1900-01-01 00:00:00 算起. NTP的时间精度在 WAN 为 数十毫秒, 在 LAN 为 亚毫秒级甚至更高, 在 Internet 上绝大部分能提供 1-50ms 的精确度, 取决于同步源和网络路径等特性. 比如: 当前时间为 1902-01-01 01:01:01, 与 1900 的参考时间相差为: (3652246060+3600+60+1) = 63075661s = 0x03C2754D s. 转换成二进制: 0000 0011 1100 0010 0111 0101 0100 1101 XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX. 因为只有 32 Bits 表示秒数, 所以到了 2036 年数据就会溢出. 所以以 136 年为一个周期置 0 , 会用一些外部的方法来表示是相对于 1900 年还是 2036 年的时间. NTP 的未来版本可能将时间表示扩展到 128 Bits: 其中 64 Bits 表示秒, 64 Bits 表示秒的小数. 当前的 NTPv4 格式支持 “时代数字” (Era Number)和 “时代偏移” (Era Offset), 正确使用它们应该有助于解决日期翻转问题. 据Mills称: “64 Bits 秒的小数足以分辨光子以光速通过电子所需的时间. 64 Bits 的秒足以提供明确的时间表示, 直到宇宙变暗.” Originate Timestamp: NTP请求报文离开发送端时发送端的本地时间, 长度为 64 Bits. Receive Timestamp: NTP请求报文到达接收端时接收端的本地时间, 长度为 64 Bits. Transmit Timestamp: 应答报文离开应答者时应答者的本地时间, 长度为 64 Bits. Authenticator(Optional): 验证信息, 长度为 96 Bits, (可选信息), 当实现了 NTP 认证模式时, 主要标识符和信息数字域就包括已定义的信息认证代码 (MAC) 信息. 识别机制抗干扰和恶意破坏: 为防止对时间服务器的恶意破坏, NTP使用了识别 (Authentication) 机制. 检查来对时的信息是否是真正来自所宣称的服务器并检查资料的返回路径, 以提供对抗干扰的保护机制. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:3:0","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"四.实例分析 时间服务器接收同步消息,应答反馈的数据如下: 1c0104ec 00000000 00000048 47505373 dd26aa9f f7e47f4e dd26aaa7 4f5022d9 dd26aaa7 5f6f1524 dd26aaa7 5f716a6a 长度为 48 Bytes. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:4:0","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"wireshark 抓包如下: ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:4:1","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["NTP","Network"],"content":"解析数据 1c0104ec转换成二进制:0001 1100 0000 0001 0000 0100 1110 1100 00.. …. = Leap Indicator: no warning (0) ..01 1… = Version Number: NTP Version 3 (3) …. .100 = Mode: Server (4) 0000 0001 = Peer Clock Stratum: primary reference (1) 0000 0100 = Peer Polling Interval: 4 (2^4 = 16s) 1110 1100 = Peer Clock Precision: -20 (2^-20 = 0.000001s). ps: (补码: 1110 1100, 转换为反码: 1110 1011, 转换为原码: 0001 0100 = 20. 添加符号为 -20, 精度为 2^-20 = 0.000001s.) 00000000 秒数为 0000, 秒的小数为 0000. 所以: Root Delay: 0.0000s 00000048 秒数为 0000, 秒的小数为 0048, 转换二进制: 0000 0000 0100 1000. Root Dispersion: (0 + 2^-10 + 2^-13 = 0.0011s). 47505373 采用ASCII码, Reference ID: Unidentified reference source ‘GPSs’ dd26aa9f f7e47f4e 秒数为 dd26aa9f, 转换成 Unix 时间戳 (1900年 转换为 1970年开始): 0xdd26aa9f - 0x83aa7e80 = 0x597c2c1f = 1501309983 即 2017-07-29 14:33:03. 秒的小数为 f7e47f4e, 转换成二进制: 1111 0111 1110 0100 0111 1111 0100 1110 = 2^-1 + 2^-2 + 2^-3 + 2^-4 + 2^-6 + 2^-7 + 2^-8 + 2^-9 + 2^-10 + 2^-11 + 2^-14 + 2^-18 + 2^-19 + 2^-20 + 2^-21 + 2^-22 + 2^-23 + 2^-24 + 2^-26 + 2^-29 + 2^-30 + 2^-31 = 0.968330000. Reference Timestamp: 2017-07-29 14:33:03.068330000s UTC +08:00. dd26aaa7 4f5022d9 秒数为 dd26aaa7 = 2017-07-29 14:33:11. 秒的小数为 4f5022d9 = 0.309816000. Reference Timestamp: 2017-07-29 14:33:11.309816000s UTC +08:00. dd26aaa7 5f6f1524 秒数为 dd26aaa7 = 2017-07-29 14:33:11. 秒的小数为 5f6f1524 = 0.372788000. Reference Timestamp: 2017-07-29 14:33:11.372788000s UTC +08:00. dd26aaa7 5f716a6a 秒数为 dd26aaa7 = 2017-07-29 14:33:11. 秒的小数为 5f716a6a = 0.372824000. Reference Timestamp: 2017-07-29 14:33:11.372824000s UTC +08:00. ","date":"0001-01-01","objectID":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/:4:2","tags":["NTP","Network","Linux"],"title":"NTP协议简单分析","uri":"/ntp%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"categories":["Linux","Network"],"content":"简单介绍 tcpdump 是一款强大的网络抓包工具，运行在 linux 平台上。熟悉 tcpdump 的使用能够帮助你分析、调试网络数据。 要想使用很好地掌握 tcpdump， 必须对网络报文（TCP/IP 协议）有一定的了解。不过对于简单的使用来说，只要有网络基础概念就行了。 tcpdump 是一个很复杂的命令，想了解它的方方面面非常不易，也不值得推荐，能够使用它解决日常工作中的问题才是关键。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:1:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"选项 tcpdump 的选项也很多，要想知道所有选项的话，请参考 man tcpdump，下面只记录 tcpdump 最常用的选项。 完整的英文文档：https://www.tcpdump.org/tcpdump_man.html 需要注意的是，tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。 -n 表示不要解析域名，直接显示 ip。 -nn 不要解析域名和端口 -X 同时用 hex 和 ascii 显示报文的内容。 -XX 同 -X，但同时显示以太网头部。 -S 显示绝对的序列号（sequence number），而不是相对编号。 -i any 监听所有的网卡 -v, -vv, -vvv：显示更多的详细信息 -c number: 截取 number 个报文，然后结束 -A： 只使用 ascii 打印报文的全部数据，不要和 -X 一起使用。截取 http 请求的时候可以用 sudo tcpdump -nSA port 80！ ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:2:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"以太网帧的封包格式为： Frame = Ethernet Header + IP Header + TCP Header + TCP Segment Data Ethernet Header =14 Byte =Dst Physical Address（6 Byte）+ Src Physical Address（6 Byte）+Type（2 Byte），以太网帧头以下称之为数据帧。 IP Header =20 Byte（without options field），数据在IP层称为Datagram，分片称为Fragment。 TCP Header = 20 Byte（without options field），数据在TCP层称为Stream，分段称为Segment（UDP中称为Message）。 54个字节后为TCP数据负载部分（Data Portion），即应用层用户数据。 Ethernet Header以下的IP数据报最大传输单位为MTU（Maximum Transmission Unit，Effect of short board），对于大多数使用以太网的局域网来说，MTU=1500。 TCP数据包每次能够传输的最大数据分段为MSS，为了达到最佳的传输效能，在建立TCP连接时双方将协商MSS值——双方提供的MSS值中的最小值为这次连接的最大MSS值。MSS往往基于MTU计算出来，通常**MSS**=MTU-sizeof(IP Header)-sizeof(TCP Header)=1500-20-20=1460。 这样，数据经过本地TCP层分段后，交给本地IP层，在本地IP层就不需要分片了。但是在下一跳路由（Next Hop）的邻居路由器上可能发生IP分片！因为路由器的网卡的MTU可能小于需要转发的IP数据报的大小。 这时候，在路由器上可能发生两种情况： （1）如果源发送端设置了这个IP数据包可以分片（May Fragment，DF=0），路由器将IP数据报分片后转发。 （2）如果源发送端设置了这个IP数据报不可以分片（Don’t Fragment，DF=1），路由器将IP数据报丢弃，并发送ICMP分片错误消息给源发送端。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:2:1","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"简单使用（实例） ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:3:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"tcpdump -vv 默认启动，普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:3:1","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"tcpdump -nS 监听所有端口，直接显示 ip 地址。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:3:2","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"tcpdump -nnvvS 显示更详细的数据报文，包括 tos, ttl, checksum 等。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:3:3","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"tcpdump -nnvvXS 显示数据报的全部数据信息，用 hex 和 ascii 两列对比输出。 下面是抓取 ping 命令的请求和返回的两个报文，可以看到全部的数据。 ➜ ~ sudo tcpdump -nnvXSs 0 -c2 icmp tcpdump: data link type PKTAP tcpdump: listening on pktap, link-type PKTAP (Packet Tap), capture size 65535 bytes 22:58:16.781856 IP (tos 0x0, ttl 64, id 61452, offset 0, flags [none], proto ICMP (1), length 84) 192.168.1.106 \u003e 192.168.1.1: ICMP echo request, id 65302, seq 0, length 64 0x0000: 0c72 2c28 b9ac 80e6 5019 4c38 0800 4500 .r,(....P.L8..E. 0x0010: 0054 f00c 0000 4001 06e1 c0a8 016a c0a8 .T....@......j.. 0x0020: 0101 0800 72c9 ff16 0000 5500 5808 000b ....r.....U.X... 0x0030: ee08 0809 0a0b 0c0d 0e0f 1011 1213 1415 ................ 0x0040: 1617 1819 1a1b 1c1d 1e1f 2021 2223 2425 ...........!\"#$% 0x0050: 2627 2829 2a2b 2c2d 2e2f 3031 3233 3435 \u0026'()*+,-./012345 0x0060: 3637 67 22:58:17.674304 IP (tos 0x0, ttl 64, id 13972, offset 0, flags [none], proto ICMP (1), length 84) 192.168.1.1 \u003e 192.168.1.106: ICMP echo reply, id 65302, seq 0, length 64 0x0000: 80e6 5019 4c38 0c72 2c28 b9ac 0800 4500 ..P.L8.r,(....E. 0x0010: 0054 3694 0000 4001 c059 c0a8 0101 c0a8 .T6...@..Y...... 0x0020: 016a 0000 7ac9 ff16 0000 5500 5808 000b .j..z.....U.X... 0x0030: ee08 0809 0a0b 0c0d 0e0f 1011 1213 1415 ................ 0x0040: 1617 1819 1a1b 1c1d 1e1f 2021 2223 2425 ...........!\"#$% 0x0050: 2627 2829 2a2b 2c2d 2e2f 3031 3233 3435 \u0026'()*+,-./012345 0x0060: 3637 67 2 packets captured 5875 packets received by filter 0 packets dropped by kernel ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:3:4","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"过滤器 机器上的网络报文数量异常的多，很多时候我们只关系和具体问题有关的数据报（比如访问某个网站的数据，或者 icmp 超时的报文等等），而这些数据只占到很小的一部分。把所有的数据截取下来，从里面找到想要的信息无疑是一件很费时费力的工作。而 tcpdump 提供了灵活的语法可以精确地截取关心的数据报，简化分析的工作量。这些选择数据包的语句就是过滤器（filter）！ 过滤器也可以简单地分为三类：type, dir 和 proto。 Type 让你区分报文的类型，主要由 host（主机）, net（网络） 和 port（端口） 组成。src 和 dst 也可以用来过滤报文的源地址和目的地址。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"host: 过滤某个主机的数据报文 tcpdump host 1.2.3.4 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:1","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"src, dst: 过滤源地址和目的地址 tcpdump src 2.3.4.5 tcpdump dst 3.4.5.6 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:2","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"net: 过滤某个网段的数据，CIDR 模式 tcpdump net 1.2.3.0/24 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:3","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"proto: 过滤某个协议的数据，支持 tcp, udp 和 icmp。使用的时候可以省略 proto 关键字。 tcpdump icmp ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:4","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"port: 过滤通过某个端口的数据报 tcpdump port 3389 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:5","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"src/dst, port, protocol: 结合三者 tcpdump src port 1025 and tcp tcpdump udp and src port 53 此外还有指定端口和数据报文范围的过滤器： ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:6","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"port 范围 tcpdump portrange 21-23 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:7","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"数据报大小，单位是字节 tcpdump less 32 tcpdump greater 128 tcpdump \u003e 32 tcpdump \u003c= 128 过于过滤器的更多详细信息，请访问 tcpdump 官方 map page 的 PCAP-FILTER 部分 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:4:8","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"输出到文件 使用 tcpdump 截取数据报文的时候，默认会打印到屏幕的默认输出，你会看到按照顺序和格式，很多的数据一行行快速闪过，根本来不及看清楚所有的内容。不过，tcpdump 提供了把截取的数据保存到文件的功能，以便后面使用其他图形工具（比如 wireshark，Snort）来分析。 -w 选项用来把数据报文输出到文件，比如下面的命令就是把所有 80 端口的数据导入到文件 # sudo tcpdump -w capture_file.pcap port 80 -r 可以读取文件里的数据报文，显示到屏幕上。 # tcpdump -nXr capture_file.pcap host web30 NOTE：保存到文件的数据不是屏幕上看到的文件信息，而是包含了额外信息的固定格式 pcap，需要特殊的软件（如：Wireshark）来查看，使用 vim 或者 cat 命令会出现乱码。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:5:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"强大的过滤器 过滤的真正强大之处在于你可以随意组合它们，而连接它们的逻辑就是常用的 与/AND/\u0026\u0026、 或/OR/|| 和 非/not/!。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:6:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"源地址是 10.5.2.3，目的端口是 3389 的数据报 tcpdump -nnvS src 10.5.2.3 and dst port 3389 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:6:1","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"从 192.168 网段到 10 或者 172.16 网段的数据报 tcpdump -nvX src net 192.168.0.0/16 and dat net 10.0.0.0/8 or 172.16.0.0/16 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:6:2","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"从 Mars 或者 Pluto 发出的数据报，并且目的端口不是 22 tcpdump -vv src mars or pluto and not dat port 22 从上面的例子就可以看出，你可以随意地组合之前的过滤器来截取自己期望的数据报，最重要的就是知道自己要精确匹配的数据室怎样的！ 对于比较复杂的过滤器表达式，为了逻辑的清晰，可以使用括号。不过默认情况下，tcpdump 把 () 当做特殊的字符，所以必须使用单引号 ' 来消除歧义： tcpdump -nvv -c 20 'src 10.0.2.4 and (dat port 3389 or 22)' ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:6:3","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"实例一 tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))' 抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:6:4","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"实例二 tcpdump -i eth1 '((icmp) and ((ether dst host 00:01:02:03:04:05)))' 抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:6:5","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"实例三 tcpdump -i eth1 '((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))' 抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:6:6","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"理解 tcpdump 的输出 截取数据只是第一步，第二步就是理解这些数据，下面就解释一下 tcpdump 命令输出各部分的意义。 21:27:06.995846 IP (tos 0x0, ttl 64, id 45646, offset 0, flags [DF], proto TCP (6), length 64) 192.168.1.106.56166 \u003e 124.192.132.54.80: Flags [S], cksum 0xa730 (correct), seq 992042666, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 663433143 ecr 0,sackOK,eol], length 0 21:27:07.030487 IP (tos 0x0, ttl 51, id 0, offset 0, flags [DF], proto TCP (6), length 44) 124.192.132.54.80 \u003e 192.168.1.106.56166: Flags [S.], cksum 0xedc0 (correct), seq 2147006684, ack 992042667, win 14600, options [mss 1440], length 0 21:27:07.030527 IP (tos 0x0, ttl 64, id 59119, offset 0, flags [DF], proto TCP (6), length 40) 192.168.1.106.56166 \u003e 124.192.132.54.80: Flags [.], cksum 0x3e72 (correct), ack 2147006685, win 65535, length 0 最基本也是最重要的信息就是数据报的源地址/端口和目的地址/端口，上面的例子第一条数据报中，源地址 ip 是 192.168.1.106，源端口是 56166，目的地址是 124.192.132.54，目的端口是 80。 \u003e 符号代表数据的方向。 此外，上面的三条数据还是 tcp 协议的三次握手过程，第一条就是 SYN 报文，这个可以通过 Flags [S] 看出。下面是常见的 TCP 报文的 Flags: [S]： SYN（开始连接） [.]: 没有 Flag [P]: PSH（推送数据） [F]: FIN （结束连接） [R]: RST（重置连接） 而第二条数据的 [S.] 表示 SYN-ACK，就是 SYN 报文的应答报文。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:7:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"比较常用的方式 如果是为了查看数据内容，建议用tcpdump -s 0 -w filename把数据包都保存下来，然后用wireshark的Follow TCP Stream/Follow UDP Stream来查看整个会话的内容。-s 0是抓取完整数据包，否则默认只抓68字节。用tcpflow也可以方便的获取TCP会话内容，支持tcpdump的各种表达式。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:8:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"UDP头 0 7 8 15 16 23 24 31 +--------+--------+--------+--------+ | Source | Destination | | Port | Port | +--------+--------+--------+--------+ | | | | Length | Checksum | +--------+--------+--------+--------+ | | | DATA ... | +-----------------------------------+ /*UDP头定义，共8个字节*/ typedef struct _UDP_HEADER { unsigned short m_usSourPort; //源端口号16bit unsigned short m_usDestPort; //目的端口号16bit unsigned short m_usLength; //数据包长度16bit unsigned short m_usCheckSum; //校验和16bit }__attribute__((packed))UDP_HEADER, *PUDP_HEADER; 抓DNS请求数据 tcpdump -i eth1 udp dst port 53 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:8:1","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"系统测试 -c参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工CTRL+C还是抓的太多，甚至导致服务器宕机，于是可以用-c参数指定抓多少个包。 time tcpdump -nn -i eth0 'tcp[tcpflags] = tcp-syn' -c 10000 \u003e /dev/null 上面的命令计算抓10000个SYN包花费多少时间，可以判断访问量大概是多少。　","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:8:2","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"tcpdump 与wireshark Wireshark(以前是ethereal)是Windows下非常简单易用的抓包工具。但在Linux下很难找到一个好用的图形化抓包工具。 还好有Tcpdump。我们可以用Tcpdump + Wireshark 的完美组合实现：在 Linux 里抓包，然后在Windows 里分析包。 tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap　 tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型 -i eth1 : 只抓经过接口eth1的包 -t : 不显示时间戳 -s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包 -c 100 : 只抓取100个数据包 dst port ! 22 : 不抓取目标端口是22的数据包 src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24 -w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:8:3","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"使用tcpdump抓取HTTP包 tcpdump -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854　 0x4745 为\"GET\"前两个字母\"GE\" 0x4854 为\"HTTP\"前两个字母\"HT\" tcpdump 对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带**-w**参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序(如Wireshark)进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。 基本上tcpdump总的的输出格式为：系统时间 来源主机.端口 \u003e 目标主机.端口 数据包参数 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/:8:4","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令使用简介","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"},{"categories":["Linux","Network"],"content":"首先了解如何从包头过滤信息 proto[x:y] : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（第一字节从0开始排） proto[x:y] \u0026 z = 0 : proto[x:y]和z的与操作为0 proto[x:y] \u0026 z !=0 : proto[x:y]和z的与操作不为0 proto[x:y] \u0026 z = z : proto[x:y]和z的与操作为z proto[x:y] = z : proto[x:y]等于z 操作符 : \u003e, \u003c, \u003e=, \u003c=, =, != ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:0:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"IP头（IPV4） 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Version| IHL |Type of Service| Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identification |Flags| Fragment Offset | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time to Live | Protocol | Header Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | \u003c-- optional +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | DATA ... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 中文： /*IP头定义，共20个字节*/ typedef struct _IP_HEADER { char m_cVersionAndHeaderLen; //版本信息(前4位)，头长度(后4位) char m_cTypeOfService; // 服务类型8位 short m_sTotalLenOfPacket; //数据包长度 short m_sPacketID; //数据包标识 short m_sSliceinfo; //分片使用 char m_cTTL; //存活时间 char m_cTypeOfProtocol; //协议类型 short m_sCheckSum; //校验和 unsigned int m_uiSourIp; //源ip unsigned int m_uiDestIp; //目的ip } __attribute__((packed))IP_HEADER, *PIP_HEADER ; 版本： ​ 指IP协议的版本，通信双方使用的IP协议版本必须一致。一般的值为0100（IPv4），0110（IPv6）。 首部长度： ​ 长度4比特。这个字段的作用是为了描述IP包头的长度，因为在IP包头中有变长的可选部分。该部分占4个bit位，单位为32bit（4个字节），即本区域值= IP头部长度（单位为bit）/(84)，因此，一个IP包头的长度最长为“1111”，即154＝60个字节。IP包头最小长度为20字节。 优先级与服务类型： ​ 长度8比特，定义了数据包传输的紧急程度以及时延、可靠性、传输成本等。 总长度： ​ 16比特，以字节为单位描述IP包的总长度（包括头部和数据两部分），最大值为65535。第二行中标识符、标志和段偏移量通常联合使用，用于数据拆分时的分组和重组。 标识符： ​ 对于上层发来的较大的数据包，往往需要拆分。路由器将一个大包进行拆分后，拆出来的所有部分被标上相同的值，该值即为标识符，用于告诉目的端哪些包属于同一个大包。 标志： ​ 长度3比特。该字段第一位不使用。第二位是DF（Don’t Fragment）位，DF位设为1时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。第三位是MF（More Fragments）位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的IP包的包头中将MF位设为1。 段偏移量： ​ 长度13比特，表示一个数据包在原先被拆分前的大包中的位置。接收端据此来还原和组装IP包。 TTL： ​ 表示IP包的生存时间，长度8比特。长度8比特。当IP包进行传送时，先会对该字段赋予某个特定的值。当IP包经过每一个沿途的路由器的时候，每个沿途的路由器会将IP包的TTL值减少1。如果TTL减少为0，则该IP包会被丢弃。这个字段可以防止由于路由环路而导致IP包在网络中不停被转发。 协议号： ​ 长度8比特，标识上一层即传输层在本次数据传输中所使用的协议。比如6代表TCP，17代表UDP等 首部校验和： ​ 长度16位。用来做IP头部的正确性检测，但不包含数据部分。 因为每个路由器要改变TTL的值,所以路由器会为每个通过的数据包重新计算这个值。 源地址： ​ 长度32比特，标识IP包的起源地址。 目标地址： ​ 长度32比特，表示IP包的目的地址。 可选项： ​ 可变长字段，主要用于测试，由起源设备跟据需要改写。 填充： ​ 因为IP包头长度（Header Length）部分的单位为32bit，所以IP包头的长度必须为32bit的整数倍。因此，在可选项后面，IP协议会填充若干个0，以达到32bit的整数倍 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:1:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"IP选项 一般的IP头是20字节，但IP头有选项设置，不能直接从偏移21字节处读取数据。IP头有个长度字段可以知道头长度是否大于20字节。 通常第一个字节的二进制值是：01000101， 分成两个部分： 0100 = 4 表示IP版本 0101 = 5 表示IP头32 bit的块数， 5 x 32 bits = 160 bits or 20 bytes 如果第一字节第二部分的值大于5，那么表示头有IP选项。 下面介绍有过滤方法 **0100 0101 **: 第一字节的二进制 0000 1111 : 与操作 \u003c========= 0000 0101 : 结果 正确的过滤方法: tcpdump -i eth1 'ip[0] \u0026 15 \u003e 5' 或者 tcpdump -i eth1 'ip[0] \u0026 0x0f \u003e 5'　 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:2:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"分片标记 当发送端的MTU大于到目的路径链路上的MTU时就会被分片，分片信息在IP头的第七和第八字节： +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Flags| Fragment Offset | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Bit 0: 保留，必须是0 Bit 1: (DF) 0 = 可能分片, 1 = 不分片 Bit 2: (MF) 0 = 最后的分片, 1 = 还有分片 Fragment Offset字段只有在分片的时候才使用。 要抓带DF位标记的不分片的包，第七字节的值应该是： 01000000 = 64 tcpdump -i eth1 'ip[6] = 64' ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:3:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"抓分片包 匹配MF，分片包 tcpdump -i eth1 'ip[6] = 32' 最后分片包的开始3位是0，但是有Fragment Offset字段。 匹配分片和最后分片 tcpdump -i eth1 '((ip[6:2] \u003e 0) and (not ip[6] = 64))' 测试分片可以用下面的命令： ping -M want -s 3000 192.168.1.1 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:4:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"匹配小TTL TTL字段在第九字节，并且正好是完整的一个字节，TTL最大值是255，二进制为11111111。 可以用下面的命令验证一下： $ ping -M want -s 3000 -t 256 192.168.1.200 ping: ttl 256 out of range +-+-+-+-+-+-+-+-+ | Time to Live | +-+-+-+-+-+-+-+-+ 在网关可以用下面的命令看看网络中谁在使用traceroute tcpdump -i eth1 'ip[8] \u003c 5' ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:5:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"抓大于X字节的包 大于600字节 tcpdump -i eth1 'ip[2:2] \u003e 600' ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:6:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"更多的过滤方式 首先还是需要知道TCP基本结构 TCP头 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Port | Destination Port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Acknowledgment Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | |C|E|U|A|P|R|S|F| | | Offset| Res. |W|C|R|C|S|S|Y|I| Window | | | |R|E|G|K|H|T|N|N| | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Checksum | Urgent Pointer | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 　 /*TCP头定义，共20个字节*/ typedef struct _TCP_HEADER { short m_sSourPort; //源端口号16bit short m_sDestPort; //目的端口号16bit unsigned int m_uiSequNum; //序列号32bit unsigned int m_uiAcknowledgeNum; //确认号32bit short m_sHeaderLenAndFlag; //前4位：TCP头长度；中6位：保留；后6位：标志位 short m_sWindowSize; //窗口大小16bit short m_sCheckSum; //检验和16bit short m_surgentPointer; //紧急数据偏移量16bit }__attribute__((packed))TCP_HEADER, *PTCP_HEADER; /*TCP头中的选项定义 kind(8bit)+Length(8bit，整个选项的长度，包含前两部分)+内容(如果有的话) KIND = 1表示 无操作NOP，无后面的部分 2表示 maximum segment 后面的LENGTH就是maximum segment选项的长度（以byte为单位，1+1+内容部分长度） 3表示 windows scale 后面的LENGTH就是 windows scale选项的长度（以byte为单位，1+1+内容部分长度） 4表示 SACK permitted LENGTH为2，没有内容部分 5表示这是一个SACK包 LENGTH为2，没有内容部分 8表示时间戳，LENGTH为10，含8个字节的时间戳 */ 16位源端口号和16位目的端口号。 32位序号： ​ 一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。 32位确认号： ​ 用来响应TCP报文段，给收到的TCP报文段的序号加1，三握时还要携带自己的序号。 4位头部长度： ​ 标识该TCP头部有多少个4字节，共表示最长15*4=60字节。同IP头部。 6位保留： ​ 6位标志。URG（紧急指针是否有效）ACK（表示确认号是否有效）PSH（提示接收端应用程序应该立即从TCP接收缓冲区读走数据）RST（表示要求对方重新建立连接）SYN（表示请求建立一个连接）FIN（表示通知对方本端要关闭连接） 16位窗口大小： ​ TCP流量控制的一个手段，用来告诉对端TCP缓冲区还能容纳多少字节。 16位校验和： ​ 由发送端填充，接收端对报文段执行CRC算法以检验TCP报文段在传输中是否损坏。 16位紧急指针： ​ 一个正的偏移量，它和序号段的值相加表示最后一个紧急数据的下一字节的序号。 标志位字段（U、A、P、R、S、F）： 占6比特。各比特的含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文段交给应用层。 RST：重建连接。 SYN：发起一个连接。 FIN：释放一个连接。 窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。 TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。 紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 选项字段：占32比特。可能包括\"窗口扩大因子\"、“时间戳\"等选项。 抓取源端口大于1024的TCP数据包 tcpdump -i eth1 'tcp[0:2] \u003e 1024' 匹配TCP数据包的特殊标记 TCP标记定义在TCP头的第十四个字节 +-+-+-+-+-+-+-+-+ |C|E|U|A|P|R|S|F| |W|C|R|C|S|S|Y|I| |R|E|G|K|H|T|N|N| +-+-+-+-+-+-+-+-+ 只抓SYN包，第十四字节是二进制的00000010，也就是十进制的2 tcpdump -i eth1 'tcp[13] = 2' 抓SYN, ACK （00010010 or 18） tcpdump -i eth1 'tcp[13] = 18' 抓SYN或者SYN-ACK tcpdump -i eth1 'tcp[13] \u0026 2 = 2' 抓PSH-ACK tcpdump -i eth1 'tcp[13] = 24' 抓所有包含FIN标记的包（FIN通常和ACK一起，表示幽会完了，回见） tcpdump -i eth1 'tcp[13] \u0026 1 = 1' 抓RST tcpdump -i eth1 'tcp[13] \u0026 4 = 4' ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:7:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"常用的字段偏移名字 tcpdump考虑了一些数字恐惧症者的需求，提供了部分常用的字段偏移名字： icmptype (ICMP类型字段) icmpcode (ICMP符号字段) tcpflags (TCP标记字段) ICMP类型值有： icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply TCP标记值： tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg 这样上面按照TCP标记位抓包的就可以写直观的表达式了： 只抓SYN包 tcpdump -i eth1 'tcp[tcpflags] = tcp-syn' 抓SYN, ACK tcpdump -i eth1 'tcp[tcpflags] \u0026 tcp-syn != 0 and tcp[tcpflags] \u0026 tcp-ack != 0' ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:8:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"抓SMTP数据 tcpdump -i eth1 '((port 25) and (tcp[(tcp[12]\u003e\u003e2):4] = 0x4d41494c))' 抓取数据区开始为\"MAIL\"的包，“MAIL\"的十六进制为0x4d41494c。 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:9:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"抓HTTP GET数据 tcpdump -i eth1 'tcp[(tcp[12]\u003e\u003e2):4] = 0x47455420' “GET “的十六进制是47455420 ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:10:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"},{"categories":["Linux","Network"],"content":"抓SSH返回 tcpdump -i eth1 'tcp[(tcp[12]\u003e\u003e2):4] = 0x5353482D' 　“SSH-“的十六进制是0x5353482D tcpdump -i eth1 '(tcp[(tcp[12]\u003e\u003e2):4] = 0x5353482D) and (tcp[((tcp[12]\u003e\u003e2)+4):2] = 0x312E)' ","date":"0001-01-01","objectID":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/:11:0","tags":["TCPDump","Network","Linux"],"title":"tcpdump命令高级过滤方式","uri":"/tcpdump%E5%91%BD%E4%BB%A4%E9%AB%98%E7%BA%A7%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F/"}]